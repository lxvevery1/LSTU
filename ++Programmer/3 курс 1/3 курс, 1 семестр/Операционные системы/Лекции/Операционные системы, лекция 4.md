## Multitasking
Операционная система - платформа, на которой делается что-то полезное. Многозадачность - способность параллельно управлять ресурсами для выполняющихся приложений.

Реализовать многозадачность ядра нереально, но можно быстро переключаться из одного потока в другой (context-switching), вызывая прерывание. Если переключение контекста происходит быстро, то за секунду при 100 потоках все 100 потоков работают параллельно (очень быстро последовательно переключаются между собой)

В современном программировании существует множество паттернов, среди них есть Reactor - этот паттерн, который позволяет кооперативную многозадачность. Т.е. способ как в одном потоке делать квази-параллельность.

### Hyperthreading 
Лет 10 назад разработчики процессоров в погоне за производительностью пришли к тому, что в процессе выполнения одной команды будет 2 контекста исполнения (threads) -> внутри процессора образуются псевдо-ядра. Реально когда первый thread выполняется, он занимает какие-то ресурсы CPU, в этот момент эти ресурсы не дают остальным процессам. 

До недавнего разделения ядер (perf, effect) , все ядра были одинаковыми. 

Как происходит процесс переключения (dispatch)?
Для того, чтобы ОС могла обрабатывать поток создается объект task (место памяти, в котором есть данные). В составе этого объекта есть ячейка для сохранения контекста исполнения.

Существует 256 видов прерываний. Какие-то из int-ов могут быть назначены на соотв. прерывания по выбору программиста (при записи в регистр прерываний). Каждое прерывание возникает при опред. условии. Interrupt vector table (для каждого номера прерываний существует  указатель инструкций). Когда возникло прерывание interrupt handler получает управление, созраняет контекст исполнения в стеке, выбирает соотв вектор, переключается на исполнение interrupt handler, сохраняет контекст в объекте прерванного task. 

### Планировщик (Scheduler)
Это компонент диспетчера, который принимает решение какая из готовых к исполнению задач будет исполняться в CPU core следующей. Чтобы все потоки исполнялись эффективно нужно. Планировщиком управляет программист, выставляя значения свойств задач:
	scheduling policy
		SHED_DEADLINE
		SCHED_FIFO
			Есть приоритеты 1, 2, ... -> с каждым приоритетом может быть связана очередь задач task queue. Когда появляется новая задача, ей назначается приоритет. Если есть очередь, то из очереди выбирается задача, приоритет которой наивысший (0, 1, 2, ...) Поскольку задача ожидает очередь, она не используется процессором  
		SCHED_RR(round_robing)
		SCHED_OTHER / SCHED_BATCH / SCHED_IDLE
	priority - статический приоритет (1..99)
	nice - относительный приоритет (-20..+19)
### Time slicing (разделение времени)
Похоже на FIFO, но накладываются ограничения (время, которое задача может выполняться -> после происходит прерывание -> задача уходит в конец очереди приоритета)
