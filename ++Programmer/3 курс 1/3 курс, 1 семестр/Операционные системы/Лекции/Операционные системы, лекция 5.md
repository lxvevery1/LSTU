## Виртуальная память.

Адресация
mov RAX, [DRA]
Какая из ячеек будет записана в RAX?
RDA - x64 регистр,  в котором лежит число и эти комбинации битом и называются адресом
RDA - адрес 1000
Mov, в нашем случае, заносит 1000ую ячейку в RAX

Виртуальная память - между нашим прогр. кодом, исполняемым CPU и физич. памятью со своим адресом (0x)
Между ними механизм: Диспетчер памяти
Преобразовать адрес ячейки в число 1000.
У каждого процесса есть virtual address space. 
Если процесс k хочет обратиться к памяти ячейки 1, то у него это не получиться. Только к своим ячейкам, хоть и в процессе 1 то же самое. 
Каждый процесс представляет собой объект ОС. В каждом процессе инф. о нем в диспетчере: список потоков, ip, состояние регистров, mode.
У каждого процесса свое собственное динамическое адресное пространство. Внутри процесса памятью управляет процессный код. Там лежит исполняемый код (из исполняемого модуля), там будут какие-нибудь данные. У каждого потока будет свой стек (потому что исполнение кода требует стека). Heap (все разделяют в процессе).
Все эти места в памяти будут соответствовать каким-нибудь адресам. Этот адрес будет доступен всем потокам в этом процессе. Один и тот же код может исполняться множеством процессов. Потоки создают, либо иллюзию, либо действительное исполнение процесса. Потоки могут обмениваться данными (через ссылку на объект). 

Linux:
	Первый запущенный процесс после загрузки - init - физически, это исполняемый модуль, который должен создать все остальные процессы
	fork() - функция, которая создает новый процесс или его копию
	R = fork() - создать процесс.
	У клонированных процессов создается копия адресного пространства. Этот процесс может работать с данными клонированного процесса. 
	Связь между род. и дочерним процессом накладывает ответственность на род. процесс. При завершении родительского процесса все его дочерние процессы будут убиты. Родительскую связь можно разрушить. Для того чтобы этого не произошло, род. процессу нужно дождаться, пока все дочерние процессы остановятся. Родительский процесс должен дождаться и получить код завершения дочернего процесса. Именно в тот момент, когда дочерний процесс завершился, а родитель не принял код возврата, доч. процесс становится zombie. 

Windows:
	В Windows заместо fork() есть createProcess()
	Имеет 2 основных параметра: command и arg
	Команда в процесс загружает другой процесс. У него будут точно такие же зависимости.

Как управлять процессами? 
### Механизм сигнала. 
Процесс может получать сигналы. Сигнал - это толчок, событие. Процесс может вызвать системный вызов signal. Есть команда - kill, её параметр - номер сигнала и id процесса. 
kill -1 153
Сигналы нужны для того, чтобы:
	1. Сообщить об ошибке
	2. Взаимодействовать с пользователем
		1. sigterm (ctrl+c in terminal)
		2. sighub (когда обрывается линия пользователя)
		3. sigkill (процесс убивается)
		4. sigstop (приостановить действие процесса)
		5. sigcont 
		6. sigusr1
		7. sigusr2
	3. Асинхронность
		1. sigalarm - просьба ядра послать сигнал alarm через некоторое время
		2. sigio - read завершается
	4. Межпроцессное взаимодействие
	5. RT-сигналы
		1. Они не расписаны по функциям
		2. Имеют нефиксированные номера

Как работают сигналы?

Процесс как-то реагирует на них. Какая возможная реакция?
Реакции:
1. ignore
2. terminate
3. terminate(core) (для анализа причины сигнала(информация хранится в core))
4. catch - процедура при принятии сигнала

Обработка понятия сигнала происходит на уровне диспетчера. Каждый раз, когда диспетчер загружает процесс в cpu, проверяет на наличие сигналов.
У процесса есть pending сигналов. Поле, в котором отводится бит на хранение ожидающих сигналов. sigprocmask - маска сигнала (авоид сигнала)
У signalpending есть массив сигналов, обработчик сигналов. У пользователя тоже есть обработчик сигналов. Default-обработчик - terminate.

### Обработка сигнала 
Если есть handler, то у него есть точка входа. -> в этом векторе указывается точка входа. Если при факте диспетчеризации обнаруживается факт сигнала и он не замаскирован, то записывается signalReturn в main стек по дефолту. 

## Процессы
Есть юзер-процессы, а есть daemon-процессы. 
При загрузке системы запускается процесс ** диалога. Этот процесс является лидером процесса. В Windows поддерживается 2 сессии: user и network

Thread local storage (TLS) - специфич. возможность, применяемая для многопоточных приложений. Есть потоконебезопасная функция (выводит строки в лог -> её нельзя вызвать из каждого потока, инстанциировать тоже).


#### Процессы vs потоки
У процессов своя собственная память, а потоки функционируют без неё. 
Подчиненность: процесс сам по себе, а поток зависим от процесса.
Самосоздание: процесс запускается при исполнении файла, а поток при вызове функции
Чем владеет: процесс (адресное пр-во, дескрипторы, регистр), поток (стек, локальная память потока)
Стоимость создания: процесс-существенная, поток-относительно низка.

Ввод-вывод бывает асинхронным, блокирующий, неблокирующий, мультиплексированный.

## Память
Один из ресурсов. Как ей управлять? Сначала опишем, то , что у нас есть. 
8гб оперативной памяти -> 8 миллиардов ячеек. У каждой есть свой адрес. 
Физическое адресное пространство разделено на несколько малых областей. Память XT - адресное   пространство в 1 мб. 1 мб - $1 * 10^5$ байт -> $2^{20}$ бит.
640 кб достаточно всем? 
В 1 мб ОЗУ нужно отвести память под ПЗУ, РОМ, и т.д.
ячейка A000 - от 0 до 9FFFF.
high memory - расширенная шина (24 битная ( до 16 мб )). Содержит память предназначенную для использования пользователем.
32 бита (до 4гб)


