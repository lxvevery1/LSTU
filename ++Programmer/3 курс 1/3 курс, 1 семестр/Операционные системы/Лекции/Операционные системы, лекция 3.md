## Классификация программного кода
Программный код:
	1. Native:
		1. Intel x86
		2. ARM
		3. RISC V
	2. Emulated:
		1. Java VM (java-by-code)
		2. CLR - common language runtime
		3. WASM - byte-code inside browser
	3. Interpreter:
		1. sh / bash
		2. javaScript
		3. PHP
		4. PowerShell
		5. Lua
		6. ?python - имеет промежуточный код, поэтому не является интерпретатором

В .exe лежит все необходимое, чтобы ОС загрузила код в память, настроила и передала управление точке входа.
ОС также в runtime создает environment (набор ресурсов (память, время процессора, файлы)) (потому что код не может исполняться без взаимодействия с ней). 
Метод "открыть" и метод "прочитать" - системные вызовы (api ОС)
ABI - application binary interface - набор соглашений, по которому стоит писать программы под операционную систему.

## Конвейер создания исполняемых модулей
Исполняемые модули - исполняются из исполняемого конвейера (pipeline)
Compiler + Linker + Archivator
Объектный модуль - скомпилированный несобранный файл.
Linker - настраивает связи на библиотеки (готовит файл (генерирует список необходимых библиотек), но не загружает в оперативную память)
Библиотека - коллекция объектных файлов (printf.c)
В ОС лежат десятки тысяч .exe и ~90% требуется функция printf - это огромная затрата памяти и чтобы экономить ресурсы придумали концепт разделяемых библиотек. Разделяемая библиотека - это executable module (ОС загружает её в память и использует ссылки на её модули (отдельные функции))

Есть 3 вида исполняемых модулей:
	1. Абсолютные модули (прошивка устройства [адрес памяти - значение]). 
	2. Исполняемый модуль:
		1. Распределение памяти (память, используемая в процессе неоднородна (сегменты памяти) 
		2. Ссылки на необходимые разделенные библиотеки -> .exe -> .dll -> .dll -> ... - этим занимается Loader
		3. Символы(имена ячеек), на которые возможны ссылки извне.
		4. Адрес точки входа и другая информация
	3. Объектный модуль (relocatable module): .obj, .o. Нужно собрать все модули, чтобы запустить программу. Поэтому компилятор при компиляции создает абстрактный модуль, чтобы распределить файлы в памяти.

### Зачем так сложно?
- **_принцип конструктора Лего_**: исполняемый модуль компилируется из кода нескольких исходных модулей, каждый из которых может разрабатываться отдельно.
- **_разделение труда_**: программные инструменты (коллекции типовых функций, API (в т. ч. самой ОС), фреймворки...) могут разрабатываться независимо от Applications и поставляться в форме программных библиотек.
- **_совместимость бинарного кода_**: несмотря на то, что разные исходные модули могут разрабатываться на разных компилируемых языках, они могут успешно функционировать друг с другом в одном исполняемом файле.
- **_автоматизации процедуры сборки_**: linker автоматически отбирает набор объектных модулей, которые должны быть включены в состав исполняемого модуля на основании метаинформации объектных модулей (лишние модули туда не включаются)
## Память
BP - base point - отсюда отчитываются адресы к аргументам и локальным переменным.
ISS - initial stack size
![[Pasted image 20230916120611.png]]
![[Pasted image 20230916120623.png]]
![[Pasted image 20230916120639.png]]
## Что делает Linker?
Linker пытается собрать в исполняемый модуль такой (минимальный) набор объектных модулей, чтобы в их секциях были определены все Symbols, на которые ссылаются из relocations. o
![[Pasted image 20230916120647.png]]

## Управление CPU
CPU исполняет инструкции одну за одной в главном цикле. Для указания порядка исполнения используется регистр указателя следующей инструкции IP (EIP (x32), RIP (x64), PC, СчК ...)

Значение в IP может явно устанавливаться:
- в инструкциях перехода (jmp), ветвления или вызова процедуры (call): значение, заданное в операндах команды
- в инструкциях возврата (ret, iret): сокращенное значение адреса возврата из стека
- при сбросе или прерывании: определённое значение соответствующего сектора.
В остальных случаях значение IP увеличивается на длину текущей инструкции. Т.е. инструкции выполняются последовательно в порядке их расположения в памяти, если нет явных инструкций и/или прерываний.

Поток (thread) - процесс выполнения инструкций и их порядок определен программистом.

Прерывание - набор предопределенных точек, которые можно перенаправить. С каждым видом прерываний связан Interrupt vector.

## Механизм прерываний
Прерывание (interrupt) - это процедура, исполняемая CPU core (почти самостоятельно) в качестве реакции на возникновение некоторого условия прерывания.
Условия прерываний:
	interrupts: внешние прерывания
	exceptions: события, возникающие в процессе выполнения программы
		Ошибки, детектируемые CPU.
		Прерывания, вызываемые специальными инструкциями.

Есть внешние и внутренние прерывания:
_multitasking soon..._
