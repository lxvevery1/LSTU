The SOLID Principles @2022 Unity Technologies


SOLID is a mnemonic acronym for five core fundamentals of software design:
— Single responsibility
— Open-closed
— Liskov substitution
— Interface segregation
— Dependency inversion
Let’s examine each concept and see how they help you make your code more
understandable, flexible, and maintainable.


<b>
Single-responsibility principle
</b>

A class should have one reason to change, just its single responsibility
The first and most important SOLID principle is the single-responsibility principle
(SRP), which states that each module, class, or function is responsible for one
thing and encapsulates only that part of the logic.
Assemble your projects from many smaller ones instead of building monolithic
classes. Shorter classes and methods are easier to explain, understand, and
implement.
If you’ve worked in Unity for a while, you’re likely already familiar with this
concept When you create a GameObject, it holds a variety of smaller
components For example, it might come with:
— A MeshFilter that stores a reference to the 3D model
— A Renderer that controls how the model surface appears onscreen
— A Transform component that stores scale, rotation, and position
— A Rigidbody if it needs to interact with the physics simulation
Each component does one thing and does it well You build an entire scene from
GameObjects The interaction between their components is what makes a game
possible
You’ll construct your scripted components in the same way Design them so
each one can be clearly understood Then have them work in concert to make
complex behavior

If you ignore single responsibility, you might create a custom component that does
this:
** page 9 **

This UnrefactoredPlayer class has a mishmash of responsibilities It plays a
sound when a player collides with something, manages input, and handles
movement. Even if the class is relatively short at the moment, it will become
tricky to maintain as your project evolves. Consider breaking the Player class
into smaller classes.
** page 10 **

A Player script can still manage the other scripted components but each class
does only one thing This design makes it more approachable to revise the code,
especially as the requirements for your project change over time.
On the other hand, however, you need to balance the single-responsibility
principle with a good dose of common sense. Don’t oversimplify to the
extreme by creating classes with just one method.
Keep these objectives in mind when working with the single-responsibility
principle:
— Readability: Short classes are easier to read There is no hard and fast rule
but many developers set a limit of 200-300 lines Determine for yourself
or as a team what constitutes “short ” When you exceed this threshold,
decide if you can refactor it into smaller parts
— Extensibility: You can inherit from small classes more easily
Modify or replace them without fear of breaking unintended features
— Reusability: Design your classes to be small and modular so that you can
reuse them for other parts of your game
When refactoring, consider how rearranging code will improve the quality of life
for yourself or other team members Some extra effort at the beginning can save
you a lot of trouble later.

<b>
Open-closed principle
</b>
The open-closed principle (OCP) in SOLID design says that classes must be
open for extension but closed for modification. Structure your classes so that
you can create new behaviour without modifying the original code.
A classic example of this is calculating the area of a shape. You can make a
class called AreaCalculator with methods to return the area of a rectangle
and circle.
For the sake of calculating area, a Rectangle class has a Width and Height
A Circle only needs a Radius and the value of pi.

** page 12 **

This works well enough, but if you want to add more shapes to your
AreaCalculator, you’ll need to create a new method for each new shape.
Suppose you want to pass it a pentagon or an octagon later? What if you need 20
more shapes? The AreaCalculator class would quickly balloon out of control
You could make a base class called Shape and create one method to process
the shapes However, doing so would require multiple if statements inside
the logic to handle each type of shape That won’t scale well
You want to open the program for extension (the ability to use new shapes) without
modifying the original code (the internals of the AreaCalculator) Though it’s
functional, the current AreaCalculator violates the open-closed principle.

** page 13 **

Instead, consider defining an abstract Shape class:

** page 13 **

This includes an abstract method called CalculateArea If you then make
Rectangle and Circle inherit from Shape, each shape can calculate its own
area and return the following result:

** page 13 **

The AreaCalculator can simplify into this:

** page 14 **

The revised AreaCalculator class can now get the area of any shape that
properly implements the abstract Shape class You can then extend the
AreaCalculator functionality without changing any of its original source

** page 14 **

Every time you need a new polygon, simply define a new class that inherits from
Shape Each subclassed shape then overrides the CalculateArea method to
return the correct area.
This new design makes debugging easier If a new shape introduces an
error, you don’t have to revisit the AreaCalculator The old code remains
unchanged, so you only need to examine new code for any faulty logic.
Take advantage of interfaces and abstraction when creating new classes in
Unity This helps to avoid unwieldy switch or if statements in your logic that
will be difficult to extend later. Once you get accustomed to setting up your
classes to respect OCP, adding new code in the long term becomes simpler.

<b>
Liskov substitution principle
</b>
The Liskov substitution principle (LSP) states that derived classes must be
substitutable for their base class. Inheritance in object-oriented programming
allows you to add functionality through subclasses. However, this can lead to
unnecessary complexity if you’re not careful.
The Liskov substitution principle, the third pillar of SOLID, tells you how to
apply inheritance to make your subclasses more robust and flexible.
Imagine your game requires a class called Vehicle. This will be the base class
of a vehicle subclass that you will create for your application. For example, you
might need a car or truck

** page 15 **

Everywhere you can use the base class (Vehicle), you should be able to use a
subclass like Car or Truck without breaking the application.

Your Vehicle class might look like this:

** page 16 **

Suppose you are building a turn-based game where you move the vehicles around a board

** page 16 **

You could have another class called Navigator to steer a vehicle along a
prescribed path:

** page 17 **

With this class, you expect to be able to pass any vehicle into the Navigator’s
Move method, and this will work fine with cars and trucks. What happens,
though, when you want to implement a class called Train?

** page 17 **

The TurnLeft and TurnRight methods would not work in a Train class since
a train can’t leave its tracks If you do pass a train into the Navigator’s Move
method, that would throw an unimplemented Exception (or do nothing) when
you get to those lines You violate the Liskov substitution principle if you cannot
substitute a type for its subtype.

Since a Train is a subtype of Vehicle, you would expect to use it any place
that accepts the Vehicle class. Doing otherwise might make your code behave
unpredictably.
Consider some tips to adhere more closely to Liskov substitution principle:
— If you are removing features when subclassing, you are likely breaking
Liskov substitution: A NotImplementedException is a dead giveaway
that you’ve violated this principle. Leaving a method blank does so as well
If the subclass does not behave like the base class, you’re not following
LSP – even if there’s no explicit error or exception
— Keep abstractions simple: The more logic you put into the base class the
more likely you will break LSP. The base class should only express the
common functionality of the derived subclasses
— A subclass needs to have the same public members as the base class:
Those members also need to have the same signatures and behavior
when calling them.
— Consider the class API before establishing class hierarchies:
Even though you think of them all as vehicles, it might make more
sense for a Car and Train to inherit from separate parent classes
Classifications in reality don’t always translate into class hierarchy
— Favor composition over inheritance: Instead of trying to pass
functionality through inheritance, create an interface or separate class to
encapsulate a specific behavior Then build up a “composition” of different
functionality by mixing and matching

** page 18 **

To fix this design, scrap the original Vehicle type, then move much of the
functionality into interfaces

** page 19 **

Follow the LSP principle more closely by creating a RoadVehicle type and
RailVehicle type The Car and Train would then inherit from their respective
base classes

** page 20 **

In this way the functionality comes through interfaces rather than inheritance.
Car and Train no longer share the same base class, which now satisfies LSP.
Though you could derive RoadVehicle and RailVehicle from the same base
class, there is not much need to in this case.
This way of thinking can be counterintuitive because you have certain
assumptions about the real world. In software development, this is called
the circle–ellipse problem. Not every actual “is a” relationship translates into
inheritance. Remember, you want your software design to drive your class
hierarchy, not your prior knowledge of reality.
Follow the Liskov substitution principle to limit how you use inheritance to keep
your codebase extendable and flexible.

<b>
Interface segregation principle
</b>
The interface segregation principle (ISP) states that no client should be forced
to depend on methods it does not use.
In other words, avoid large interfaces. Follow the same idea as the single-
responsibility principle, which tells you to keep classes and methods short.
This gives you maximum flexibility, keeping interfaces compact and focused.
Imagine you’re making a strategy game with different player units. Each unit
has different stats like health and speed You might want to make an interface
to guarantee that all of the units implement similar features:
** page 21 **

Let’s say you want to make a destructible prop like a breakable barrel or crate.
This prop will also need the concept of health despite not moving A crate or barrel
also won’t have many of the abilities associated with other units in the game
Split it into several smaller interfaces rather than make one interface that gives
the breakable prop too many methods A class implementing them will then
only mix and match what it needs.

** page 23 **

You can also add an IExplodable interface for the exploding barrel:

** page 24 **

Because a class can implement more than one interface, you can compose
an enemy unit from IDamageable, IMoveable, and IUnitStats
An exploding barrel could use IDamageable and IExplodable without needing
the unnecessary overhead of the other interfaces

** page 25 **

Again, this favors composition over inheritance, similar to the example with
Liskov substitution. The interface segregation principle helps decouple your
systems and makes them easier to modify and redeploy.

<b>
Dependency inversion principle
</b>

The dependency inversion principle (DIP) says that high-level modules should
not import anything directly from low-level modules. Both should depend on
abstractions.
Let’s unpack what that means. When one class has a relationship with another,
it has a dependency or coupling. Each dependency in software design carries
some risk.
If one class knows too much about how another class works, modifying the
first class can damage the second or vice versa A high degree of coupling is
considered unclean code practice An error in one part of the application can
snowball into many.

Ideally, aim for as few dependencies between classes as possible. Each class
also needs its internal parts to work together in unison, rather than relying on
connections to the outside. Your object is considered cohesive when it functions
on internal or private logic.
In the best scenario, aim for loose coupling and high cohesion.

You need to be able to modify and expand your game application. If it’s fragile
and resistant to modification, investigate how it’s currently structured.
The dependency inversion principle can help reduce this tight coupling between
classes. When building classes and systems in your application, some are
naturally “high-level” and some “low-level”. A high-level class depends on a
lower-level class to get something done. SOLID tells us to switch this up.

Suppose you are making a game where a character explores the level and
triggers a door to open You might want to create a class called Switch and
another class called Door.

On a high level, you want the character to move to a specific location and for
something to happen. The Switch will be responsible for that.
On a low level is another class, Door, that contains the actual implementation
of how to open the door geometry. For simplification, a Debug.Log statement is
added to represent the logic of the opening and closing door.

** page 27 **

Switch can invoke the Toggle method to open and close the door. It works,
but the problem is that a dependency is wired from the Door directly into the
Switch What if the logic of the Switch needs to work on more than just a
Door for example, to activate a light or giant robot?

You can add extra methods into the Switch class, but you’d be violating the
open-closed principle. You have to modify the original code every time you want
to extend functionality.
Once again abstractions come to the rescue. You can sandwich an interface
called ISwitchable in between your classes.

ISwitchable just needs a public property so you know whether it’s active, plus
a couple of methods to Activate and Deactivate it.

Then the Switch becomes something like this, depending on an ISwitchable
client, instead of a door directly.

** page 28 **

Now you’ve inverted the dependency. The interface creates an abstraction in
between them rather than hardwiring the switch to the door exclusively. The Switch
no longer depends directly on the door-specific methods (Open and Close)
Instead it uses the ISwitchable’s Activate and Deactivate.
This small but significant change promotes reusability. Whereas Switch would
only work with a Door previously, now it works with anything that implements
ISwitchable.

This enables you to make more classes that the Switch can activate The high-
level Switch will work, whether it’s a trap door or a laser beam It just needs a
compatible client that implements ISwitchable.

Like the rest of SOLID, the dependency inversion principle asks you to examine
how you normally set up relationships between your classes. Conveniently scale
your project with loose coupling.
