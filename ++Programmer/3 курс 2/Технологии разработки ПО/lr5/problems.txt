Рефакторинг: Основные ошибки

RaceCompetition.cs (CalcCarRacePlace method):
    1. Большой размер метода. Из-за чего нарушается целостность, и я не могу исправлять одну часть кода, не думая о безопасности другой.
        1.1 Порождается огромный объем пояснительных комментариев, которых можно избежать, разбив метод на несколько методов поменьше. Время, когда можно было экономить RAM на уменьшенном числе вызове методов, прошли. И сегодня этим можно пожертвовать в угоду читаемости программы. Ведь с небольшим, независимым блоком кода, который имеет свое название, намного приятнее и оперативнее работать.
    2. Операции над коллекциями в циклах foreach
    3. Муравейко ещё на первом курсе учил объявлять требуемые переменные в начале функций (в данном случае, методе)

Score.cs:
    1. Нет придерживаемости общего стиля. Какие-то поля названы с использованием Аппер-кейса, какие-то нет. Причем всё это выполнено хаотично, строгостью в наименованиях и не пахнет 
    2. Используемые константы не объявлены (получается эффект магических чисел - непонятно за что отвечает, непонятно где ещё будет использоваться)
    3. Куча повторений, которых можно избежать, чрезмерное использование условий
    4. Некорректные названия полей (необоснованное использование public модификатора)


Как эти проблемы можно исправить?

RaceCompetition.cs (CalcCarRacePlace method):
    1. Разбить метод на логические части.
        1.1 Вынести код независимых блоков в отдельные методы. Я создал новые методы: для получения словарей: Ключ - это чекпоинт, а значение - список автомобилей, сортировка по локальным прогрессиям (процентное прохождение пути между чекпоинтом n и n+1), финальная сортировка по полученным глобальным прогрессиям.
    2. Упростить работу в циклах (заменить цикл foreach на for). Оказывается, в циклах типа foreach нельзя редактировать содержимое оперируемых коллекций. Поэтому мне приходилось создавать дубликаты этих коллекций, делать их оперируемыми, а уже затем изменять оригиналы. Глупость, конечно, но когда я начинал работать над методом, я не знал что это сильно увеличит размер моей программы во всех смыслах.
    3. Самое простое - вынести все объявленные переменные в начало метода (в блок INIT). Кстати говоря, в результате этого действия, у меня получилось не только сделать объявления всех переменных в методе намного нагляднее, но и убрать несколько лишних.
    
Score.cs:
    1. Теперь соблюдаем грамотные отступы: между блоками объявленных полей, между объявленными полями и методами, между блоками методов, имеющими разные модификаторы. Кстати, модификаторы полей или методов в хорошей программе, на мой взгляд, тоже должны быть отсортированы: сначала объявляются публичные, затем защищённые и потом приватные поля/методы
    2. В больших программах порой тяжело ориентироваться, из-за того, что доступ к тем или иным параметрам "зарыты" в нижней части файла с методами программы, там, где и прописывается вся логика. Зачем куда-то лезть, искать нужный метод, затем нужную строчку, когда можно вынести эту константу в самый верхний блок объявления полей. Но самое главное, на мой взгляд, здесь даже не доступность, а понятность. Мы даем константе имя, с котором она теперь обретает новый смысл. 
Этим механизмом "пузыря" не стоит злоупотреблять, так как какие-нибудь 0 или 1, где они логически и так уместны, можно и не выносить в список полей, так как это действие будет только захламлять код.
    3. Вот это приходит с опытом. Мне нравится смотреть свои старые работы и видеть в них тонну копипаста, хотя на тот момент я мог даже и не подозревать, что это решение, возможно, одно из самых неправильных. В рассматриваемом скрипте буквально каждый метод можно упростить, если использовать списки или массивы, метод Increment() самый интересный: в нем я использовал if дважды там, где без него можно легко обойтись, используя массив, а также такие механизмы как: тернарный оператор ? и оператор интерполяции строк $.
    4. Не задумываясь о важности механизма инкапсуляции, расставлены публичные модификаторы там где нужно и нет. Решается несложно: спросить себя 'А нужен ли мне вызывать этот метод/поле в других классах [Публичность]? Если нет, то буду ли я его применять в классах-наследниках [Защищенность]? Если и тут нет, то можно смело приватизировать поле или метод.'
