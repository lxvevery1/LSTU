### Канальный уровень сети
Основная задача - порцию данных доставить на соседний узел (узел, который подлкючен к общему звену передачи данных). Обеспечивает транспорт пакета с одного узла на другой. Для этого канальный модуль.
Протокол канального уровня - единица канального уровня - кадр.
Есть модуль канального уровня linkLayer. ARP и ip - два протокола, рабоатющие внутри канального уровня. Интерфейс канального уровня работает в виде пакетов. 
Модуль протокола x имеет некоторые функции, который вызывает протоколы (send packet этот пакет по данному звену -> ip модуль может взаимодействовать с несколькими канальными модулями)
Для того, чтобы доставить порцию данных на соседний уровень пакеты нужно инкапсулировать (ведь канальный протокол не может менять пакет, а та инфа которая нужна ему есть в заголовке, который образует кадр). После инкапсуляции кадра надо преобразовать его в поток битов. Ведь в физ. уровне есть только поток битов, значит нужно кадр преобразовать в биты (кадрирование, framing). Поток битов уходит в вфиз.модуль и работает функция приема. Теперь нужно из потока выделить кадр (обратная операция). Теперь нужно проверить правильность передачи (функция канального уровня). 
Если какой-то кадр был принят с ошибкой, нужно восстановить данные. Либо попросить передать кадр повторно, либо восстановить информацию из искаженного потока. Последняя из функций - управление очередностью доступа. Несколько станций хотят передать данные, это функция управления очередности доступа. 

Модуль, который работает через проводной eth и wifi отличаются. Зависят от параметров: вид звена (симплексные, дуплексные, полудуплексныйе) Симплексные связи - тв (спутниковая тарелка),
дуплексная передача (по телефону, передача в две стороны)
Полудуплексные - радиостанция (нажал кнопку, можешь сам говорить, но ничего не слышишь)
3 Варианта режимов передачи:
побитовый, синхронный - модем телефонный (как только установилось соединение между двумя модемами, устанавливается поток, пока соединение не будет разорвано) Самое эффективное пропускание. Даже если нечего передавать, то придется что-то передать
Сихнронный - биты разбиты на актеты (символы)
Посимвольный, аснхронный (передача на физ. уровне) - компьютеры с ком. порты ( в эпоху начала сетей были здоровенные порты для конфигурирования сетевого оборудования (USB-проводник или комп.порт) ) У этого порта передача символов (актет) От 5 до 9 битов - нажимая кнопку на клавиатуре символ выплевывается в канал связи, а потом идет произвольной длины пауза.

Первая функция - кадрирование (на вход в передатчик поступают порции, если передатчик переводит порции в биты, то в канал выстраиваются биты) Как приемник поймет когда заканчивается и начинается порция? Внутри порции может быть любая комбинация битов. Требуется не просто передать, а передать с кодо-прозрачностью и разделить эту струю нельзя на отдльные блоки. Чтобы кадрирование работало, передатчик заранее модифицирует поток, добавляя свое решение. eth имеет паузы между потоками, но в побитовых синхронных каналах пауз нет. Реальное решение состоит в использовании разделителей (separator) в поток битов внедряется символ разделителя - последовательность 'флаг' 0 111111 0
Все что есть между двумя разделителями считается фреймом.
Нужно обеспечить, что в потоке не встречается больше этих флагов, для этого он модфирует поток, чтобы подобная комбинация битов не встречалась.

Самый эффективный способ преобразования - bit stuffing если передатчик обнаруживает 5 единиц подряд, то после пятой вставляет 0. Бит стаффинг приводит к тому, что поток становится больше. В реальности механизм эффективен.
Почему именно 6 единиц? Чем длинее разделитель, тем больше пропускной способности будет на это тратиться. Смысл разделителя - обособленная нулями последовательность единиц. Кадр может заканчиваться на любой символ. Эта операция осуществляется на аппаратном уровне. ПО записало в буфер информацию для передачи, а сам аппарат вставит разделители там, где это нужно.

Для символьных каналов применятся ctrl-escape 
01111101 - похожа на флаг, но этот символ вставляется, чтобы изменить интерпретацию следующего символа. По сути это доп. символ (как \\ в Си).
Данный сепаратор означает, что в следующем символе нужно инвертировать пятый (шестой) бит. Таким образом зарезервированный флаг превращается в обычный символ. При этом ctrl-escape может применяться для любых символов. Этот механизм существенно менее эффективен. Символ выглядит так: '{'

Существовал ещё один способ. SYN SYN STX Data ETX - такой способ кадрирования - посимвольный протокол (использующий такой механизм передачи данных)

Реальные каналы связи искажают данные. Поэтому любой канал связи имеет тенденцию искажения данных. Для искажения строится схема передатчик-приемник между которыми есть канал с искажениями. И при передачи из 0 в 0, а из 1 в 1 получится так что 1 станет 0, а 0 станет 1 (искажение)
BER = колво ошиб. бит / всего бит - интенсивность ошибок. Самые плохие каналы имеют ber = 5, что приводит к искажению всех битов. 
Раньше телефоны имели искажение раз в тысячу бит.
Работа на реальных каналах предполагает, что система должна уметь определять ошибки. И ошибки определяются (чаще всего) на уровне данных. Чаще всего приемник не имеет информации что нужно передать (работа тестера, так как он уже знает что нужно передать). Метод обнаружения ошибок строится на теории:
кодовое слово - некая призвольная комбинация битов, имеющая длину N битов. Кодовое слово D в общем случае принадлежит множеству из 2^N кодовых комбинаций. Если всего n битов, то возможных значений 2^N. кодовое пространство - все пространство.Lenght = 2^N. ошибка преобразует одну кодовую комбинацию в другую (искажение бита). Нужен некий способ, который фиксирует факт того, что принята комбинация (искаженная), но информации о том, что мы должны принять нет.
Без доп. информации эту ошибку не решить. Но можно ограничить целостность, например до 99%. Для того чтобы обнаруживать ошибки, все кодовое пространство делится на подмножество правильных и всез остальных - заранее приемник и передатчик договариваются на передачу только зеленых кодовых комбинаций. Поскольку передатчик никогда не получает красную кодовую комб., это детект того, что ошибка есть. Но если ошибка одну зеленую преобразует в другую зеленую, то получится необнаруживаемая ошибка. 
Хорошая новость состоит в том, что такую вероятность можно сделать сколь угодно низким (множество красных сделать большим, а множество зеленых макс. малым)
Как формировать комбинации так, чтобы этот механизм был эффективным? Способ: разделение на красное и зеленое легко реализуется путем добавления избыточности. Первая часть - информационная из n битов полезных данных. В зеленом подмножестве 2^m возмонжых комбинаций. Каждая комбинация информационных битов соответствует контрольным битам (избыточным-проверяльщикам на правильность). В этом случае биты формируются как функции контроля, поскольку функция на любой параметр отдает одно значение, то ответ будет однозначным. В итоге образуется кодовая информация, передаваемая по каналам (D'm) Берет его, рассчитывает и получает такое то значение. Остается только сравнить и верить, что сойдется.
Контроль происходит после фрейминга (после выделения порции), и в кадре есть хвостовик (контрольная сумма - комбинация контрольных битов) - это и есть кодовое слово. 

Весь вопрос состоит в том, чтобы построит схему наиболее эффективным методом. Цена - увеличение служебных данных (тратим ресурс канала на передачу). Хочется избыточность сделать как можно меньше, чем больше избыточность, с тем большей уверенностью можем диагностировать ошибку. С одной стороны надо обеспечить наименьшую избыточность, с другой эффективность.

Кодовое расстояние - 
011100101
010101010
++-++---- - в данном случае код. расстояние равно 5 (число несовпавших битов)

Эффективность системы кодирования зависит от минимального кодового расстояния (функция fcheck())

Есть самая эффективная схема с кодовым расстоянием = 2 (контроль по паритету) - предполагает что байту добавляется бит паритета (этот кнтрольный бит должен добавлять до четного, либо до нечетного числа). кодовое расстояние равно двум (если одна или нечетное кол-во ошибок возникает, то кадр искажается и приемник диагностирует ошибку)
Схема обнаруживает одинарные и нечетные ошибки, но не обнаруживает четные. 
Хочется контролироать большее количество ошибок. 
Это делает матричный код
По битам формируется паритетная формула для каждой строки и столбцов.
У матричного кода появляется свойство исправлений ошибки - если ошибки две, а не одна, то меняются двепаритетные формулы и симптом ошибки показывает паритет ошибки -> матричный код умеет обнаруживает двухкратные ошибки и исправлять однократные ошибки. 

## Код Хэмминга
Матрица строится таким образом; строятся биты, при этом образуется ряд паритетных формул 
Как построить код Хэмминга? Повернуть голову
На позиции 2^N стоят контрольные биты, в итоге получается, что остальные позиции забиты информ. битами. В случае однократной ошибки будет генерироваться синдром, определяющий позицию искаженного бита.
Код Хэмминга имеет возможность говорить прямо какой бит искажен, а цена вопроса не так кусается, в итоге добавлется один контрольный бит - 9 бит, с кодом, детектирующим все ошибки, а если ошибка однократная, то выдает синдром ECC RAM.

Все паритеты обладают общим свойством:

Реальное искажение данных в каналах связей имеют тенденцию кучкования (burst), одна мс может исказиться на десяток или сотен битов, кодов на которые не хватит. 