Мы рассматривали Netware, Protocol.
Остановились на челенжах, которые придется преодолеть

Netware должно выполнять множество функций. Применяется подход декомпозиций: структурная (один из подходов) - что такое человек? описываем структуру 2 руки, 2 ноги, ... 
Как выглядит сетевой узел?
У этого узла есть 2 слоя: интерфейсы (нижний слой) - точка подключения звеньев данных. N интерфейсов
А сверху находятся множество SAPов. M точек доступа.
Те функции, которые связаны с интерфейсов, причем внутри выделяются 2 уровня: физический и 

Пир интерфейсы - соединены друг с другом. Линк (звено) занимается тем, что полученный поток битов нарезает на порции - пакеты. Обеспечивает доставку пакета по звену. SAP - для каждого сапа создается свой модуль (экземпляр) то, что нужно выполнять в своем модуле. Функция шинкования по частям выполняется индивидуально на каждом из сапов. Все функции Netware декомпозируются и ассоциируются -> узлы-сапы-коммутаторы-звенья. -> кол-во экземпляров зависит от кол-ва структурных элементов. Сколько SAP -> сколько и точек доступов.

Не секрет, что каждый func модуль представляет собой совокупность экземпляров протокола. Внутри, например, линка могут жить хоть 15 instance протокола. Их жизнедеятельность протокольных модулей есть внешний API, кто-то снаружи может вызывать этот API, причем сам протокольный модуль может вызывать API. Экземпляр протокола X имеет верхнее API (к которому обращаются вышестоящие) и нижестоящее (к которому обращаются нижестоящие). Как протокольный модуль работает? Это не процессы, это объекты, а API - это его методы
Netware состоит из кучи протокольных модулей, которые организуют в стек. Есть 3 точки входа:
1. Если сверху со стороны сапа приложение хочет отправить сообщение -> верхний API меняет свой state, после чего может сформировать пакет и попросить его отправить. Возможность общения есть только у нижнего API. Каждый протокольный модуль ведет диалог со своим пир модулем и диалог ведет используя нижележащих отправляет PDU -> образуется нисходящий путь. Транспортный -> сетевой -> обращается к 
2. Снизу -> цепочка прерываний -> доставь сообщение, который скажет что-то процессу
3. Работа по таймеру (отсчитывают таймаут -> вызывают таймер). 

Вся эта конструкция state machine. 

## Послойная архитектура стека протоколов
Несмотря на обилие протоколов, для того чтобы они хорошо работали применяется принцип послойной архитектуры. Для того чтобы реализовать функционал netware, мы его делим на слои - func layers - это этажерка на которой раскладываются протоколы. Слои организованы в иерархию. Сверху этого черного ящика живет модуль 4го уровня, который реализует внешний network api. Он же обращается к 3 layer black box по l4 и l3 интерфейсам. Черный ящик пользуется услугами 2 уровня и т.д.... Модуль первого уровня имеет непосредственное соединение с communication lane, которому он транслирует свой сигнал. Парадигма черного ящика - те, кто обращается с уровня выше, ему не важно, как имплементирован функционал нижнего уровня. Это реализовано при помощи интерфейса.

## Cons послойной архитектуры
1. Декомпозиция функциональности.
2. Разделение интерфейса и имплементации
3. Легко разрабатывать модули под интерфейс (независимая разработка)

## Функциональные уровни (layers) netware
Исходим из структурной декомпозиции четко выделяется 5 уровней:
1. Физический уровень - функциональность работы с сигналами и потоками битов. Преобразует поток битов в сигнал.
2. Link (канальный, chanell) - функции ассоциированные с интерфейсом. Его задача -> снизу поток битов, а сверху все работают с пакетами. То есть принимает поток битов, преобразует в порцию (кадр), передает порцию данных
3. Сетевой (коммутация) - коммутатор у которого сверху m точек входа (SAP), а снизу n интерфейсов. И он обеспечивает коммутацию пакетов. Маршрутизация тут.
4. Транспортный протокол (состоит из трех уровней) - 
5. Apps, использующие услуги сети

Шлюз - разновидность узла (физ, канал, сетевой)

App Gateway - приложение, у которого есть 2 SAPа. На один приходит, с другого выполняет.

Для протокола X нижележащий протокол предоставляет интерфейс для него.
Сетевой Application представляет собой протокол. Протокол представляет двух паритетных модулей. Для поддержания их диалога пользуемся услугами сети (Send()). И только потом происходит Receive()
SAP - точка присоединения седьмого уровня к транспортному
Шлюз[Gateway] (маршрут, узел, App)
Порт - абстракция, принадлежит SAPу
Интерфейс - точка подключения узла к звену.

## Эталонные модели сетевой архитектуры
Распределение функционала на кол-во layers - это дело сетевой модели. В 80х годах пытались определить какой эталон был лучше (protocol war). Выжили 3: TCP IP, ISO OSI, IEEE 802

Подавляющее большинство устройств работают по модели TCP/IP + Phy
Этажерка - модель ISO OSI 
IEEE 802 - LLC/MAC + Phy


В модели TCP/IP нет явного разделения на канальный/физический.
В модели OSI выделены 3 верхних уровня (APP, Present, Session(установка логические соединения)): у TCP/IP граница SAP проходит между App и Transport layers

TLS - протокол, работающий в рамках прикладного кода. 
HTTP / HTTP **S** <- NO TLS

## Взаимодействие канальных модулей
Link уровни уже предназначены для передачи порций данных. Для передачи преобразуют их в поток битов и отдает физическому уровню.
Между парой link модулей появляется диалог -> кадр. линк модуль использует интерфейс физ. Сверху пришел пакет, канальный модуль его инкапсулировал в кадр, передал, потом в биты, потом в сигналы.

Сетевой уровень. Если линк уровень получает пакет, то сетевой маршрутизирует этот пакет и коммутирует куда-либо. На логическом уровне каждый сетевой модуль поддерживает диалог со всеми своими соседями. Узел B может передать только одному из своих соседей. Для того, чтобы быть соседом нужно иметь общее звено. 


Сверху живут грозди UDP (Datagram служба)
Кол-во экземпляров 