Способы кодирования - самый простейший это паритетное кодирование.
почему искажается? 
Любой паритетный подход рассчитывает два значения - 0 и 1. Это получается неэффективное использование, потому что половину сразу отбиывем. Было бы здорово, если бы было > 2 состояний.
Например, из 256 состояний одно лишь правильное, и рассчитывать пришлось бы не пару, а группу битов. И каждый контрольный бит подвалстен влиянию лишь себе, ошибки в других никак на него не влияют. Хотелось бы, чтобы на конртольный бит влиял каждый другой.
Из-за этого => вычисляется многобитовое контрольное число. 
Каким образом это можно получить?
А может перейдем в область ДМ и будем рассматривать слово как число и проводить арифмет. действия для получения контр. числа. Самый эффективный способ - есть 500 байт данных и складываем байты по xor и каждый бит зависит от своих битов, но если каждый байт умножим на некий коэффициент получим некоторую сумму, отбираем последние k битов и используем их как контр. число.
Код карты содержит контрольную цифру (банк. карта)
Арифметические операции дорогие, а коэффициентов нужно много (на каждый байт).
А если использовать свойство делимости (остаток от деления)
Берем число, делим на известный делитель и получаем остаток от деления (и он будет зависеть от каждого бита и будет уникальным). Его будет легко проверить (снова получить остаток в результате повторного деления).
Исходное число умножаем на 2^k. Если его прибавить, то получим остаток от деления == 0.
## Cyclic redundancy code
Блок делится на 2 части:
	информационную часть
	контрольную часть
Чтобы всё число делилось на некую константу (полином G)
Такая константа будет только одна. Для того чтобы деление упростить его считают как деление двоичных многочленов.
Также как есть и правила арифметики также и тут в качестве объектов выбраны полиномы.
Значение x в данном случае ничего не значит. x - это способ записи полинома. В этом полиноме полностью описывает коэффициент дельта. Очень лгкая арифметика:
Сложение и вычитание - xor, а умножениеи - логическое 
($0*0 = 0, 0*1=0, 1*1 = 1$)
Деление многочленов в столбик
## Формирование CRC
...
свойства:
функция остаток x(G) обладает свойством
Искажение - это вектор ошибок E. 
Если mod(D,G)=0 и mod (D',G)=mod[E,G]
исходное число d из канала пришло d' (с искажением) делим на образующий полином(const), если ошибка есть, то остаток от деления будет, а если 0, то ошибок нет. 
Для того чтобы уменьшить вероятность ненаходки ошибки, нужно иметь длинный и простой (неприводимый) полином.
CRC код с оптимальным полиномом может обнаруживать пакет ошибок размером k битов.
Обычно используются 48 бит.
x + 1 создает паритетную формулу.
На практике образующие полиномы стандартизованы 
crc-4, crc-16, crc-22, crc-64 ...
Основное преимущество crc - легко реализуется в виде электронной схемы. Никто не делит полином столбиком, а при помощи схемы из d триггеров
Как работает?
В начале передачи данных регистры пустые, данные начинают сдвиагться по 1 биту и модифицируются в обратные связи, в итоге когда данные прошли идет 16 нулей и в регистре образуется код crc, который надо скопировать
При приеме ситуация обратная: в результате должен сгенерироваться 0. 
## Другие методы контроля
### Код Рида-Соломона.
Кодовое слово в коде Р-С делятся на байты (когда crc использует биты)
Какие-то инфо биты, какие-то контрольные биты (255(всего), 233(данные)). Этот код Р-С обнаруживает ошибки на уровне байта, обнаруживающая способность n-m байтов (до 22 исказившихся байтов). Байты могут располагаться в любом месте, а также может исправлять ошибки ((n-m)/2 -> 11 байтов может исправить)
Если на выходе сказать какие байты неисправны (до 22), то он может их исправить. 
	Как узнать неисправные?
Как устроен cd-диск? Концентрическая дорожка имеет блоки данных и эти блоки данных (32-28) 
Строится блок байтов следующим образом:
Как будет выглядить повреждение дорожки? Несколько рядом стоящих блоков будут выпавшими, но он выбьет всего один байт из блока и инфа про это будет. И маленькие ошибки (до 4) можно исправить, если же не удалось их исправить, то позже 4 блока полностью исправит.
LDPC коды применяются в dvb-S2/T2/C2 (спутник. тарелки),  10Gbit Ethernet, Wi-fi 802.11n (100 мб вайфай)
турбо-коды в 3G/4G сетях сотовой связи, WiMAX, NASA

На самом деле далеко не всегда исправляющих способностей кодирование позволяют получить данные без ошибок. 
Что происходит если плохой прием? Картинка разбивается (артефакты), как только предел исправляющей способности перестает справляться. 
Чтобы исправлять данные существует forward error correction. 
Исходные данные a b c по каналу передаюсся в виде a b c d. Одно из чисел лишнее.
В отличии от forward error correction в ARQ необзодим обратный канал от приемника к передатчику (фидбек канал). ARQ сигнал (arq примитивы). Когда получает сигнал, приемник говорит принял он его или нет. 
Базовый алгоритм состоит из трех уровней сложности
1. Протокол arq с остановкой и ожиданием
		Передатчик передает данные порциями и ждет, пока ему не придет подтверждение о приеме (примитив, передаваемый по обратному каналу - ack(подтверждение))
		В нормальном состоянии передатчик имеет возможность получить порцию. Если порция исказилась, то ситуация контролируется тайм аутом. Если таймер истек, а ничего не пришло, то дата будет отправлена повторно. Есть параметр максимального количества последовательных ошибок, в результате срабатывания прерывает повторные отправки.
		Существует таймаут из-за ack, но в этом случае таймаут возникнет в передатчике и для того чтобы не возникло повторений, у каждого кадра есть номер. 
		Одновременно в состоянии передачи может находиться 1 кадр. Любая ошибка требует достижение таймаута (таймаут должен быть с запасом (> roundtrip)) -> любая ошибка будет простаивать из-за остановки. Как сделать так, чтобы канал не простаивал?
2. Принцип скользящего окна.
		Кадры имеют фиксированный размер. Макс. пакетов, например, 3. Их отправляют, их состояние == отправлен, если пришло подтверждение на пакет1 было получено, его состоние меняется и теперь можно отправить пакет4.
3. ARQ с возвращением на n кадров (go-back-n)
		при передаче первого кадра передатчик продолжает передавать кадры в пределах текущего окна не дожидаясь подствержения, только когда окно полностью исчерпано передатчик останавливается и ждет получения подтверждения (если размер окна недостаточен).
		У этого протокола непростой алгоритм. 
		Если приемник принял кадр с номером n(send)=n(receive), игнорирует данные (пропуск кадра)
		если n(s) =n(r)+1: посылает ack n(s) и принимает данные
		если n(s) > n(r)+1: посылает ack n(r)+1, игнорирует данные (пропуск кадра)
		Если окно достаточного размера и канал не будет ошибаться, то протокол будет срабатывать на 100%. 
## Как выбрать оптимальную величину размера окна?
n - размер неподтвержденных кадров (размер окна)
если n слишком большое, то много данных передается повторно. round trip time (путешествие туда-обратно). Для того, чтобы канал не простаивал, то нужно выбрать такой n, чтобы $Q = rtt*v$ - емкость каналов, тогда N = Q/S+1
Емкость канала (зависит от скорость + задержка)
Главным недостатком является повтор, начиная с N. В общем случае приемник не знает что и в каком кол-ве передавал и реагировать повторной передачей тяжело. 
Из-за потребности передавать нужные кадры, нужно знать их номера.
Это редко применяется на канальном уровне. 
Буфер на ресивере нужен для того: при обнаружении узнает плохой кадр и просит запросить его, а остальные запоминает в буфере.