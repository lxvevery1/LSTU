Service access points (SAP) - Точки, между которыми доставляется траффик. Это логический объект, который напоминает файловый дескриптор. Выступают в роли endpoint (имперсонализируют (представляют)) Эндпоинт может существовать и без SAP, но к нему нельзя будет обратиться. Dataграмма - приложение выдает порцию данных
2 режима обмена 
поток - генерирует последовательность байтов
Сеть предоставляет разные варианты обмена. SAPы разного типа "лежат в разных namespacах"
Для того чтобы сеть работала достаточна её поддержка в ОС. Чтобы передать данные нужно указать куда, для этого нужна система идентификации - адресация - уникальная комбинация, которая позволяет отличать один Endpoint от другого.
Адрес SAPа составной:
1. Тип SAPа (потоковый или dataграмма)
2. Адрес узла или же интерфейс (как номер дома в почтовом адресе)
3. Номер порта (как номер квартиры или почтового ящика)

Что должно сделать приложения чтобы воспользоваться услугами сети.
Есть приложение A (код + дата)
Внутри ОС должно быть netware + звенья передачи данных, маршруты для связи.
Если приложение не сделает действие, то невозможно на него повлиять через сеть
Первое действие, которое должно сделать приложение для передачи данных - это подготовка Endpoint (пара буферов в памяти S [Send] + R [Receive]). Буфер передачи - участок памяти приложения, куда **оно положит данные** для передачи данных по сети
Буферы здесь выступают в роли endpointа. То есть ему придется выделить эти буферы для приема и передачи данных для каждого endpointа. В буфер кладутся порции данных (если dataграмма, то должен быть datagrammWeightMax), иначе поменьше
Создание endpointа - в сетевом API есть аналог os.open(), в котором регистрирует себя в сетевом сервисе. При создании SAPа им присваивается уникальный адрес <Тип SAP> <Сетевой адрес> <Номер порта>

Процедура обмена данными составная:
Создание логического соединения (будто соединение через телефонную сеть (ожидание - набор номера - разговор)) - ассоциация двух SAPов - связь между ними что будем передавать будет в peer SAP. Здесь одно из приложений вызовет Connect(адрес для ассоциации), затем другое приложение вызовет access() и примет данные или не вызовет и не примет, тогда данные в его SAPе останутся null
Send - положить данные в буфер доставки 
Receive - положить данные в буфер получения

Если левая нода скажет Send, то, транспортированные данные в итоге будут в буфере R и придет индикация о приходе данных, сетевой инфраструктурой. Send complete не означает, что данные приняты адресатом, только лишь, что буфер Send пуст.

Так как работа с сетью является частью программного кода, имеет свое API.
Для того чтобы создать сокет есть функция 
sock_hdl = socket()
Функция Connect(sock_hdl, dst_addr) - присоединение
send (sock_hdl, buf, len) - отправить порцию данных
recv (sock_hdl, buf, len) - запросить получение порции принятых данных.

Почему нельзя воспользоваться сетью без сокета? Потому что сеть не будет знать про приложение.

Звено передачи данных (node) состоит из netware и сетевого адаптера. Часть функции сети выполняются сетевым адаптером. Есть 2 типа: тупые (минимум действий) и умные (программная и/или физическая обработка данных). Физически узлы сети реализуются на каждом узле такой связкой. Ноды (узлы) netware выполняют прием, передача, коммутация. Netware работает с порциями, которые хранятся в буфере. 

Число адаптеров = числу звеньев

Логический интерфейс (network interface) (lo0 - loop back interface) - позволяет общаться через сетевой механизм процессам внутри сетевого узла. Когда физ. адаптер off, то он уже не является интерфейсом. 

Виртуальные интерфейсы - программные интерфейсы, эмулирующие сетевой интерфейс

Интерфейсы создаются динамически (то есть мы не увидим интерфейс до подключения физического кабеля)


Чем занимается netware? Получает/Создает порции и размещает в буфер
Каждую порцию netware должен обработать -> прямо в ячейке, где лежит порция что-то меняется, затем netware решает куда порцию отправлять (up, down, выкинуть).
Netware не работает как процесс, а работает как часть ядра - по событиям. 
Сетевые адаптеры генерируют прерывания и дает ему следующую задачу либо дает состояние idle. Механизм timeout (прерывание по таймеру). 