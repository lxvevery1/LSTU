Есть 2 основных транспортных протокола. Они обеспечивают 2 режима - датаграммный и поточный. UDP - тонкая обертка над айпи, чтобы внутри одного узла можно было создать много ...
TCP намного сложнее. В UDP передаются датаграммы, отдельные изолированные порции данных - 65000 байт, а у TCP нет порций данных, есть поток. Эта последовательность байтов. Внутри TCP есть ARQ, значит гарантирует целостность потока. Если пакет по дороге потерялся, то TCP обеспечит доставку данных. TCP обязательно треубет выполнить процедуру установки соединения (привет, как длеа?). Это нужно для установления счетчиков ARQ - ns и 
На уровне TCP возможен обмен point-to-point. Общение с 20 абонентами требует создания 20 соединений. В UDP же есть multicast, broadcast. TCP более функциональный, ценой этому большие накладные расходы, которые сильно замедляют.

Транспортный модуль сверху предоставляет приложению API. Этот API можно разделить на 4 группы:
	1. Управление сокетами. На уровне Linux API open() close()
	2. Управление адресацией сокетов.
	3. Управление соединением. С TCP требуетя функция connect() [to server], listen() accept() [from server]

### Функции транспортного уровня
TCP модуль умеет регулировать темп передачи сегментов в сеть, чтобы сеть могла пропустить их через себя (конгешн контрол)

### Идентификация SAP внутри узла
В SAP каждый экземпляр протокла транспортного уровня должен иметь идентификацию (как составной ключ в бд) из трех элементов: протокол транспорта, айпи адрес, номер порта.
Что такое номер порта? Это просто число - 65535 max. Первые 1024 номера были признаны привелигированы. их привелигированность определяется их сокет с таким номером может открыть только root user (например, с портом 50). 
У нас не получится создать сокет с айпи адресом соседнего узла. Просто открыть сокет, открыв адрес, приближающийся к адресу гугла нельзя, только на локалке. Есть узел A, на нем есть 4 сокета. 
Комбинация - сокет внутри узла уникален. Нельзя создать перекрывающие друг друга сокеты
S1 -> UDP: 0.0.0.0:80 - такой сокет будет отзываться на любой айпи адрес этого узла
S2 -> TCP: 0.0.0.0:26432 - любой адрес, но не любой порт.
функция bind() - содержит какой назначить айпи и порт. Если программист бинд() не вызывал, но вызвал конект(), то когда конект() поймет что сокет ненумерованный, то сокету автоматом назначится адрес.
Эфемералы - эфемерные порты - существуют на период открытия сокета, потом освобождаются. Заранее сказать адрес сокета непросто, если его сами не присвоили.
UDP: 172.234.39.11:80 открыть не получится, так как он пересечется с S1

### Сценарий испльзования UDP
сценарий прост ->
сначала функция socket с параметрами AF_INET - хотим сокет в пространстве Ipv4
Когда нужен bind() - когда нужно управлять адресом сокета. Когда программируем сервер, чтобы другие могли указывать конкретный адрес для соединения.
Что делать с номерами портов? Во всех 65000 есть well-known port - локальный порт 80 - протокол HTTP. Это не закон. Это лишь традиция.

Клиенты bind() не используют, но могут. 

теперь начинается передача sendto() 

UDP - просто ip пакет. с заголовком 20+байтов. к нему добавляется UDP header с размером 8 байт. В этих 8 байт 4 поля есть source port и destination port

общая длина датаграммы 16 бит, контрольная сумма дейтаграммы(используется далеко не всегда, тогда заполняется 0000)

UPD дает создание сокета и просит операционку отправить что-то куда-то, а ОС сообщает ответ, дошло ли или нет.

**TCP - протокол с соединением.**
Мы не можем начать использование без установки peer. TCP богатый протокол, позволяет описывать какую роль играет сокет: сокеты бываю клиентские и прослушивающие.
Если 2 активных сокета придут навстречу, то соединение будет установлено.

Сценарий использования TCP
у клиента вызывается функция socket(), bind можно сделать для указания желаемого адреса, затем идет connect с адресом destination socket. Функция connect блокирует процесс. Для того чтобы начать соединение адрес сервера и порт(мб там well-known?) нужно знать. Сервер должен быть построен на уровне цикла приема запроса присоединения. socket(), bind(), listen() - listen устанавливает 2 бита для ядра, создающий socket(), но это лишь образцовый паттерн, а не сокет. accept возвращает новый сокет. Поскольку это все в цикле, на выходе будет создан сокет на каждого клиента.

Магия функции Accept

Есть 2 клиента, которые присоединяются к одному листен сокету. У каждого клиента есть айпи адрес, поскольку они висят на одном узле, у них будут разные порты (обычно эфимиральные). Оба клиента говорят что связываются с 1.1.1.1:80. Оба долетают до него и происходит магия => на узле 1.1.1.1 создается листен сокет, присоединен - заполнен протокол, айпи мой, айпи пир, порт мой, порт пир. Если придет третий клиент со своим пйпи то будет создан третий сокет со всеми прилегающими.

UDP идентификация по трем компонентам, в TCP по пяти.
А что если придет в айпи пакете номер порта, который не открыт. На уровне TCP придет диагностика.

Как TCP обменивается данными. В реальности есть цельный набор функций. Все эти функции в разных порциях, реализуют разный набор. recv - есть буфер n размера, положи туда байты которые пришли. Процедура двойной асинк организации.

Как работает send 
в прикладной программе есть буфер, передает данные модулю, копирует из буфера данных в буфер отправки. Программа может отправлять хоть по 1 байту, если каждый байт отправлять, то будет неэффективно. Когда данные положились в буфер отправки. Потом TCP проверит сложилась ли сумма байтов, и формирует сегмент, который передается для доставки.
Когда пришел сегмент размещается в буфер размещения. У функции receive берется порция байт и отдается программе. Двойная буферизация создает ряд особенностей. send ничего не отправляет, а переписываает из одной ячейки в другую. В каой конкретно момент будут отправляться данные? Если mss накопилось, то отправляем. Если не накпилось, то выполняем lenger() если в буфере не накопилось на mss, то отправим сейчас, а программа медлит и все равно отправит оставшуюся часть позже. Обычно lenger() вызывается по таймауту.
Если хотим чтобы данные были доставлены немедленно, тогда можно вызвать flush()

### Стурктура заголовка TCP сегмента.
Когда устанавливается ip соединение, то формируется поток байт.
один номер на один байт.
См картинку
ack number - номер ожидаемого байта - позволяет релизовывать ARQ на уровне

Изначально в tcp задумывалось, что есть поток данных а там можно отметитчть важные данные, например передаем аудио-поток, он обрывается и эту границу можно пердать через Urgent pointer - указатель важных данных.

## Установка TCP соединения
Three way handshaking - трехтороннее рукопожатие - клиент в тот момент времени когда вызван connect() формирует TCP сегмент с флажком SYN - в этом сегменте данных может не быть, в качестве sequence (номер) выставляется isn - initial sequence number. Он рандомный, нужен для защиты. Из-за чего соединение соединяется через случайный номер. Хакеру тяжело перехватить этот пакет.
isn - номер байта который бы посылался. Сервер, получив sin, берет accept, и отправляет sin и ack. клиент подтвержает isnc, отправив isnc+1, а также посылает isns (свой рандомный номер). Сервер его должен принять.
Почему 3 хендшейкинга? инициализируется 2 счетчика isnc, isns. sin - приглашение.

### Диаграмма состояния TCP модуля
Это state machine. Есть несколько логический состояний переклюючаются при совершении определнных событий.
Первое состояние - closed - закрыт.
Если вызвана listen(), то у сокета будет состояние listen. 
Состояние SYNSENT - с момента первой отправки до момента получения ответа из этого состояния выйдет, если получено syn + ack
состояние ESTABLISHED. Для состояния пассивного открытия, 
эти 2 блока (нижних) - это закрытие сокета. Базовый вариант закрытия. Нормальное закрытие - одна сторона посывлает функцию fin, при этом вторая сторона может отправлять свои данные, после конца отправки и подтверждения ack сокет является закрытым, данное приложение олжно быть закрытым.
SYN - первые 2 пакета хендшейкинга 
RST - reset 0 соединение нормально закрывается без доставки данных
PSH  push - доставь данные как можно скорее
ECE, CWR, NS - выставляют маршрутизаторы. Единственная тема, которую не озвучиил - window size.
Каждый раз отправитель указывать кол-во свободных в буфере байт. Если сделать receive number буфера = 0, тогда window = 0, и пир не может отправлить ни одного байта.