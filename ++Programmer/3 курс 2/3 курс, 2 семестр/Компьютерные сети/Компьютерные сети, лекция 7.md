Мы рассматриваем устройство сетевого уровня. 99% случаев сетевой уровень представлен ip модулем, ip протоколом. Его функция - доставить пакет на узел, коммутация пакетов. Если он коммутирует пакет, то в конце концов пакет достигнет узла назначения. Потом изучили для того чтобы коммутация работала нужна настройка таблицы. Для этого нужно знать как работает коммутатор. Как же заполняется таблица? Итак, Ip адреса назначаются блоками. Для того чтобы сеть правильно работала на каждое звено должен быть выделен блок адресов. Блоки не должны пересекаться. Интерфейсы на двухточечных звеньях должны иметь уникальные адреса. Рассмотрим узел A - у него 2 интерфейса, каждый со своим именем. Для того чтобы сконфигурировать узел, он должен знать всех своих соседей. Инфа в таблице

1. Сам узел (2 интерфейса, 2 адреса)
2. Соседи (4 соседа, опишем 4 строки) -> рисуем таблицу маршрутов

192.168.3.1/32 - что делать с таким пакетом, достигшим узел A -> Type=local, If=Eth0, Next-hop=null

Описав, узел, нужно добавить маршрут на соседей. К соседям есть прямые маршруты - U(Многоточечный сосед), UH(Двухточечный сосед). Многоточечный сосед, значит U

192.168.1.0/24 - Type=U, If=Eth0 192.168.1.0/28 - Type=UH, If=Ser1

Косвенный маршрут имеет цель определить кому передать свой пакет, чтобы он дошел до нужного узла. При TTL>1

Часто бывает, что есть некая сеть (узел) подключенный через единственную точку дефолт маршрут может быть только UG

1. Конфигурация узла (If)
2. Представлять топологию
3. Знать соседей

А если на одном интерфейсе одна половина интернета, а на втором вторая половина. Поскольку она присутствует на каждом узле, то для того чтобы вся сеть правильно работала нужно настроить все узлы. Где таблицу марщрутов найти? Узел это комп. или роутер. Как на комп. найти таблицу маршрутов? Если работаем под Windows, то route print Для Линукс это команда ip Первый источник - static configuration. Основной элемент вкладываемый в таблицу маршрутов - интерфейсы. Кол-во интерфейсов на компьютере нестандартно, как образуется число интерфейсов? Есть компьютер. Он состоит из hardware и software. Есть аппаратный контроллер Eth0, есть vlan, есть Bluetooth. Когда ОС загружается, то выполняет опрос оборудования и в системе инитится драйвер с каждым физическим контроллером. А контроллер уже говорит про интерфейс, а затем, после опроса, им присваиваются имена. Физический интерфейсы появляются в результате опроса. То что у нас есть контроллер не означает, что он будет работать. Интерфейс создается, но он не активен - это механизм вставки сетевого кабеля (событие). В момент включения интерфейса происходит регистрация сетевого интерфейса в ip модуле. В момент когда драйвер проиниц, и обнаружили что провод подключили сообщается что провод подключили. В любой ОС есть возможность в явном виде прописать параметры If. Логическое сетевое соединение - набор параметров для интерфейса. Если его открыть, то там есть свойства. Этот диалог не является конфигурацией интерфейса. А вот в свойствах TCP/IP уже присутствует конфигурация интерфейса. NetMask - описывает размер блока адресов - 255.255.255.128 (блок на 128 адресов) Таким образом, чтобы сконфигурировать интерфейс достаточно установить ip-адрес, маску подсети, основной шлюз (дефолт, last hope) DHCP - Dynamic Host Conf Protocol - протокол прикладного уровня (стек - поверх ethernet - ip - UDP - DHCP) В этой сети есть какие-то устройства и внутри одного из этих устройств должен находиться DHCP сервер (открыт сокет и прослушивает порт) Новый ПК подключился и все готово, автоматически ОС настроила интерфейс. Внутри DHCP сервера есть address pool. Выделение Ip адреса lease - сутки поработал, аренда кончилась. Для того чтобы протокол работал, ус-во должно с ним связаться - DHCP клиент срабатывает во время активации клиента. Можно подумать, что в сети должен быть единственный DHCP сервер - НЕТ! Их может быть many. У каждого из них пул может пересекаться. Разговаривают сообщениями - discover - все активные DHCP сервера (если все нравится) то выдают DHCP offer (я могу предложить ip address). Клиент получает все офферры и по собственному предпочтению выбирает оффер, который ему нравится, после высылает DHCP request. DHCP ack - acknovledge - конфигурация клиента заканчивается и адрес начинает использоваться. Request И discover - имеют timer, после срабатывает timeout. APIPA - подождав секунд 60 никаких DHCP предложений не поступило, то случайной генерацией чисел генерирует адрес. После опрашивает сеть, есть ли кто-то с таким адресом. И устанавливает его, если и правда никем не занято.

## Варианты задания конфигурации интерфейса.
### Как интернет вообще устроен поможет нам в этом разобраться

Интернет это не единая организация, а коллаборация многих участников. Каждый из участников является автономным и ни кому не подчиняются. Эти организации делятся на 2 категории: ISP-Internet Server Provider и Customer. ISP декларирует в своей деятельности обеспечение услуг интернет, а customer (end user) получает услуги ISP. Для предоставления услуг интернета нжуно своим кастомерам и ISP предоставлять адреса. Поэтому каждому ISP нужен свой IP-блок. Ip-блок может быть не один. Чтобы доставить кастомеру нужно учитывать две Peering - соглашение о принятии трафика. Клиенты всегда получают ip адреса из блока провайдера. Если у него будет 2 провайдера, то у него будет 2 адреса. При помощи peering префиксы анонсируются всем соседям, они начинают анонсировать другим соседям. Анонсировав блок(по BGP), весь интернет узнает о твоем блоке И все будут знать как доставить трафик тебе, а ты уже будешь знать как доставить трафик до клиента. Проблема нескольких айпи адресов. Если один упадет один, то пользоваться вторым. ISP работают без дефолтов.

15 компов + 2 на бродкасты + роутер = 18 адресов = 2^4 = 16, 2^5 = 32 <- он и нужен 192.168.0.1/XX - XX длина суффикса p=32-log2(S) Сначала делаем Alloc(выделяем нужный размер блоков), а затем Assign() Отсортируем сначала большие, а потом маленькие блоки и незанятых "дырок" не останется