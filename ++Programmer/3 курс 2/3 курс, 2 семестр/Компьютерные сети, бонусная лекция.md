Самый выажный протокол - **HTTP**.
Веб приложение -> Веб-клиенты и Веб-сервер
Веб-клиентом может быть:
1. Браузер
2. Curl

Что такое есть браузер?
Адрес + display area.
Браузеру же надо сказать какой ресурс всзять? URI [Unif Res ID]!
URL - частный случай - говорит откуда взять.
Браузеру важен URL.
Data Cache - бразуер получает ресурсы и складывает в кеш, если они понадобятся.
Net Engine - машина, которая работает с сетью - реализует протокол HTTP.
Дом - представление html в файле браузера.
GS Engine - внутри веб страницы исполняется код на виртуальной машине JS.
Браузер получил URL, очистил экран и отобразил ресурс.

### Web-server
Listen-socket -> HTTP
Веб-серверы бывают разные. Есть универсальные серверы - Apache, Nginx - отдельные автономные приложения. Помимо них есть aio.http.
Основная задача сервера - отдавать ресурсы по запросу.
Ресурсы бывают статические - файлы, каоторые лежат в файловой системе (static), а есть dynamic - выываем программный код, который возвращает данные.

MVC-паттерн - метод, который в ответ возвращает ресурс, который нужно вернуть.

Сколько URL обрабатывает сервер?
Нужнен конфиг. 
Внутри сервера есть табличка - часть URL - pass - создает виртуальную файловую систему и конфиг роутера указывает куда девать полученное дерево - конфигурирует виртуальный неймспейс сервера.

### Как устроен HTTP
HTTP - протокол классического клиент-сервера.
Синтаксически http возвращает запрос текстовых строк.  Внутри разбивает строки на составляющие части, реквест, к которому можно обратиться. Сервер реагирует на это и генерирует ответ. Классический http предполагал что на новый запрос новое соединение. HTTP1.1 после одного ответа соединение можно не обрывать. Клиент ведь не обязан ждать, пока ему придет ответ -> сервер будет отвечать, в ответе будет содержать сам ресурс.

### Структура HTTP запроса
Как выглядит запрос?
Заголовок и необязательное тело запроса + const версия протокола.
Header - ключевое слово: значение
Самая важная часть - строка request line. 
1. Verb
2. Path - та часть которая была в URL - все что после :
Часть д слеша не передается команде
Между заголовком и телом всегда пустая строка.

Как веб сервер будет реагировать на методы - его личное дело.
### Структура HTTP ответа
Коды трехзначные - 
1xx - все хорошо, но нужно дополнительно сказать (что-то сделать)
2xx - вообще все хорошо (ничего не надо делать)
3xx - Требуется действие
4xx - ошибка, которая возникла в результате неправильного запроса.
5xx - сервер не может обработать запрос

Хедер, заголовок, необязательный ответ

### Заголовки запросов
Самая мутная и обширная вещь - хедеры.
Заголовки можно понимать можно не понимать, которые обрабатываются сервером.
Заголовки:
1. Host - один сервер может обслуживать несколько сайтов на отдельном сервере. Name1.com -> 1234
2. Referrer - заполняется браузером, если активирован линк с другой страницы. В линке есть URL, а в зоголовге передаст URL страницы.
3. User Agent - как сервер поймет статистику с каких браузеров  нему заходят? 
4. Accept - между клиентом и сервером есть возможность договориться. Content Type - определяет логический вид того, что передает сервер. Он обязан быть в ответе. В запросе говориться Accept- пересень запросов, которые желательно видеть. Страница может быть просто в html, html+js, ... . Можно запросить просто, а можно запросить тип данных в .json . Accept - список того что бразуер принимает. То, что стоит на первом месте - то более предпочтительное
5. Accept lang - согласование языка - eng, ru, ...
6. Accept char set - ...
7. Set cookie
Cookie - set cookie сервера - печенье - детишки которых через лес тащила злая волшебница, были крошки следов - сервер помечает клиента куки и когда клиент пойдет к серверу, ту печеньку, которую ему положили в прошлый раз ему расскажут снова.

If modified since - здоровый ресурс, который лежит в кеше. Добавляется заголовок с датой - ты мне дай этот ресурс в том случае если он был модициирован после даты изменения, если новая, то пришли, если старая, то не надо.

### Заголовки ответов
1. Type
2. Date
3. Version
4. Content encoding
5. Content lang
6. Content lenght - размер body
7. Transfer encoding

Пакеты, которые ходят через сетевой стек, в разных местах сетевого стека могут подвергаться контроллю и модификациям и совокупность техник изначально появилась как packet-filter - firewall
Роутер - соединяет одну сеть интернет и LAN и вместо того, что передавать пакеты, он их начинает проверять:
на входе, на выходе + на каждом интерфейсе. van0 и lan0
Классная парадигма - Rule Set - что есть в пакете? Набор атрибутов - протокол, src_ip, dst_ip, TOSS, s_port, d_port.
Каждый пакет - порция данных с кучей атрибутов. В этих контрольных точках могут включаться рул сеты, которые делают проверку этих пакетов. Rule Set - набор правил.
Rule 1 - матч критерия и действие.
Каждый пакет, который проходит через соотв. контрольную точку сопоставляется с правилами в рул сете. Match scr_ip 1234. Если у пакета ip=1234, то match сработал и выполняется действие.
Action бывает - Accept, drop, log, count

Чтобы хакер не прикидывался вашим компьтером, закидывая пакеты с вашего ip, в файерволле это дело проверяется и подобные пакеты сбрасываются (drop). Чтобы хакеров побороть нужно иметь возможность динамически менять такой фильтр. Если комп хочет установить соед. с кем-нибудь из интернета нужен обратный поток данных (проходящий через firewall). Для того чтобы решить проблему применяют динамический трекинг.

В каждом типе оборудования принцип один и тот же.
Сам механиз настолько universal, что позволяет делть мно-во вещей, например conn tracker.


NAT - это Network Address Translator
Применение - маршрутизатор с одним единственным доступным ip адресом (белым)

Source NAT - преобразование адреса отправителя - роутер подменяет адрес, роуетр должен запомнить - если пакет придет на мой адрес, замени дест адрес на адрес компа. Ответный пакет придет на роутер, а порт запишется в nat table.
