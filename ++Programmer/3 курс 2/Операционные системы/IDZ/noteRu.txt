Глава 3. Процессы

Ранние компьютеры позволяли одновременно выполнять только одну программу. Это про-
грамма имела полный контроль над системой и имела доступ ко всем ее данным.
Ресурсы. Напротив, современные компьютерные системы позволяют загружать в память множество программ и выполнения одновременно. Эта эволюция
требовала более жесткий контроль и большее разделение различных процессов.
; и эти потребности привели к появлению понятия процесса, который представляет собой исполняемую программу. Процесс — это единица работы в современной вычислительной системе.
Чем сложнее операционная система, тем большего от нее ожидают пользовати. Хотя её основной задачей является выполнение пользовательских программ,
ей также необходимо позаботиться о различных системных задачах, которые лучше всего выполнять в пользовательском пространстве,
а не внутри ядра. Таким образом, система состоит из совокупности
процессов, некоторые из которых выполняют пользовательский код, другие — код операционной системы.
Потенциально все эти процессы могут выполняться одновременно с ЦП (или несколькими ЦП)
мультиплексированы между ними. В этой главе вы прочтете о том, какие процессы
такие, как они представлены в операционной системе и как они работают.

ЦЕЛИ ГЛАВЫ
• Определить отдельные компоненты процесса и проиллюстрировать, как они работают.
представлены и запланированы в операционной системе.
• Описать, как процессы создаются и завершаются в операционной системе, включая разработку программ с использованием соответствующих системных вызовов которые выполняют эти операции.
• Описывать и сравнивать межпроцессное взаимодействие с использованием общей памяти.
и передачу сообщений.
• Разрабатывать программы, использующие каналы и общую память POSIX для выполнения
межпроцессного взаимодействия.
• Описать связь клиент-сервер с использованием сокетов и удаленного ценообразования.
во время процедурных вызовов.
• Проектировать модули ядра, взаимодействующие с операционной системой Linux.

3.1 Концепция процесса

Вопрос, который возникает при обсуждении операционных систем, заключается в том, как называть
все действия процессора. Ранние компьютеры представляли собой пакетные системы, выполнявшие задания.
за которым последовало появление систем с разделением времени, на которых запускались пользовательские программы, или
задания. Даже в однопользовательской системе пользователь может иметь возможность запускать несколько программ.
одновременно: текстовый процессор, веб-браузер и пакет электронной почты. И даже
если компьютер может выполнять только одну программу одновременно, например, на встроенном
устройство, не поддерживающее многозадачность, возможно, операционной системе потребуется
поддерживать свои собственные внутренние программные действия, такие как управление памятью.
Во многом все эти виды деятельности схожи, поэтому мы называем их всеми процессами.
Хотя мы лично предпочитаем более современный термин «процесс»,
Срочная работа имеет историческое значение, как и большая часть теории операционных систем и
терминология была разработана в то время, когда основная деятельность операционной
системы были обработкой заданий. Поэтому в некоторых подходящих случаях мы используем
задание при описании роли операционной системы. В качестве примера было бы
вводить в заблуждение, чтобы избежать использования общепринятых терминов, включающих
слово задание (например, планирование заданий) просто потому, что процесс заменил задание

3.1.1 Процесс

Неформально, как упоминалось ранее, процесс — это исполняемая программа. Статус
текущей активности процесса представлена значением программы
счетчик и содержимое регистров процессора. Схема памяти
Процесс обычно делится на несколько разделов и показан на рисунке 3.1.
Эти разделы включают в себя:
• Текстовый раздел — исполняемый код.
• Раздел данных — глобальные переменные.

Обратите внимание, что размеры разделов текста и данных фиксированы, как и их размеры.
не изменяться во время работы программы. Однако секции стека и кучи могут
динамически сжиматься и расти во время выполнения программы. Каждый раз, когда функция
вызывается, запись активации, содержащая параметры функции, локальные переменные,
и адрес возврата помещается в стек; когда управление возвращается из
функции, запись активации извлекается из стека. Аналогично, куча
будет расти по мере динамического выделения памяти и уменьшаться, когда память
возвращается в систему. Хотя секции стека и кучи растут в сторону
друг друга, операционная система должна гарантировать, что они не перекрывают друг друга.
Подчеркнем, что программа сама по себе не является процессом. Программа – это
пассивный объект, например файл, содержащий список инструкций, хранящихся на диске
(часто называемый исполняемым файлом). Напротив, процесс — это активная сущность,
со счетчиком программ, указывающим следующую команду для выполнения и набором
связанных ресурсов. Программа становится процессом, когда исполняемый файл
загружается в память. Два распространенных метода загрузки исполняемых файлов
дважды щелкают значок, представляющий исполняемый файл, и вводят
имя исполняемого файла в командной строке (например, prog.exe или a.out).
Хотя два процесса могут быть связаны с одной и той же программой, они
тем не менее считаются двумя отдельными последовательностями выполнения. Например,
несколько пользователей могут использовать разные копии почтовой программы или одну и ту же
пользователь может вызывать множество копий программы веб-браузера. Каждый из них представляет собой
отдельный процесс; и хотя текстовые разделы эквивалентны, данные, куча,
и секции стека различаются. Также часто бывает процесс, который порождает множество
процессы во время их работы. Мы обсуждаем такие вопросы в разделе 3.4.
Обратите внимание, что процесс сам по себе может быть средой выполнения другого кода.
Среда программирования Java представляет собой хороший пример. В большинстве случаев
В некоторых случаях исполняемая программа Java выполняется внутри виртуальной среды Java.
машина (JVM). JVM выполняется как процесс, который интерпретирует загруженную Java.
код и выполняет действия (посредством собственных машинных инструкций) от имени этого кода.
Например, чтобы запустить скомпилированную Java-программу Program.class, нам нужно
входить
Java-программа
Команда java запускает JVM как обычный процесс, который, в свою очередь,
выполняет программу Java на виртуальной машине. Концепция – это
то же, что и моделирование, за исключением того, что код написан не для другого
набор команд, написан на языке Java.

3.1.2 Состояние процесса

По мере выполнения процесса он меняет состояние. Состояние процесса частично определяется
текущей деятельностью этого процесса. Процесс может находиться в одном из следующих
состояния:

СТРОИТЕЛЬСТВО ПАМЯТИ ПРОГРАММЫ C
На рисунке ниже показано расположение программы на языке C в памяти.
подчеркивая, как различные разделы процесса связаны с реальным C
программа. Этот рисунок аналогичен общему понятию процесса в памяти.
как показано на рисунке 3.1, с некоторыми отличиями:
• Раздел глобальных данных разделен на различные разделы для (a) инициализированных
данные и (б) неинициализированные данные.
• Для передаваемых параметров argc и argv предусмотрен отдельный раздел.
в функцию main().
Команда GNU size может использоваться для определения размера (в байтах)
некоторые из этих разделов. Предполагая имя исполняемого файла из приведенного выше
Программа C — это память, ниже приводится вывод, полученный при вводе
размер памяти команды:

текстовые данные bss dec шестнадцатеричное имя файла
1158 284 8 1450 5аа память

Поле данных относится к неинициализированным данным, а bss относится к инициализированным данным.
(bss — это исторический термин, обозначающий блок, начинающийся с символа.) Декабрь и
шестнадцатеричные значения представляют собой сумму трех разделов, представленных в десятичном и
шестнадцатеричный соответственно.

• Новый. Процесс создается.
• Бег. Указания выполняются.
• Ожидающий. Процесс ожидает какого-либо события (например, операции ввода-вывода).
завершение или прием сигнала).
• Готовый. Процесс ожидает назначения процессору.
• Прекращено. Процесс завершил выполнение.

Эти имена произвольны и различаются в разных операционных системах. Штаты
Однако то, что они представляют, можно найти во всех системах. Некоторые операционные системы-
Кроме того, они более точно описывают состояния процесса. Важно осознавать, что
в любой момент времени на любом ядре процессора может выполняться только один процесс. Много
Однако процессы могут быть готовы и ждут. Диаграмма состояний, соответствующая
к этим состояниям представлено на рисунке 3.2.

3.1.3 Блок управления процессом

Каждый процесс представлен в операционной системе элементом управления процессом.
блок (PCB) — также называемый блоком управления задачами. Печатная плата показана на рисунке 3.3.
Он содержит множество фрагментов информации, связанных с конкретным процессом.
в том числе:
• Состояние процесса. Состояние может быть новым, готовым, запущенным, ожидающим, остановленным и
скоро.
• Счетчик команд. Счетчик указывает адрес следующей инструкции.
который будет выполнен для этого процесса.
• Регистры ЦП. Регистры различаются по количеству и типу в зависимости от
компьютерная архитектура. К ним относятся аккумуляторы, индексные регистры, стек
указатели и регистры общего назначения, а также любую информацию о кодах условий.
ция. Вместе со счетчиком программ эта информация о состоянии должна быть сохранена.
когда происходит прерывание, чтобы процесс мог быть продолжен правильно
позже, когда его запуск будет перенесен.
• Информация о планировании ЦП. Эта информация включает в себя предварительный процесс
ity, указатели на очереди планирования и любые другие параметры планирования.
(В главе 5 описывается планирование процессов.)
• Информация об управлении памятью. Эта информация может включать в себя такие
элементы как значения базового и предельного регистров и таблиц страниц или
таблицы сегментов в зависимости от системы памяти, используемой операционной
система (глава 9).
• Учетная информация. Эта информация включает в себя количество процессора
и использование в реальном времени, ограничения по времени, номера счетов, номера заданий или процессов,
и так далее.
• Информация о состоянии ввода-вывода. Эта информация включает в себя список устройств ввода-вывода.
выделенный процессу, список открытых файлов и т. д.
Короче говоря, печатная плата просто служит хранилищем всех данных, необходимых для запуска.
или перезапустить процесс вместе с некоторыми учетными данными.

3.1.4 Темы

Обсуждавшаяся до сих пор модель процесса подразумевала, что процесс — это программа, которая
выполняет один поток выполнения. Например, когда процесс запущен
В программе текстового процессора выполняется один поток инструкций.
Этот единый поток управления позволяет процессу выполнять только одну задачу за раз.
время. Таким образом, пользователь не может одновременно вводить символы и запускать заклинание.
шашка. Большинство современных операционных систем расширили концепцию процесса.
чтобы позволить процессу иметь несколько потоков выполнения и, таким образом, выполнять
более одной задачи одновременно. Эта функция особенно полезна на многоядерных процессорах.
системы, в которых несколько потоков могут работать параллельно. Многопоточное слово
процессор мог бы, например, назначить один поток для управления пользовательским вводом, в то время как
другой поток запускает проверку орфографии. В системах, поддерживающих потоки, печатная плата
расширяется и включает информацию для каждого потока. Другие изменения повсюду
система также необходима для поддержки потоков. В главе 4 рассматриваются потоки в
деталь.

3.2 Планирование процессов

Цель мультипрограммирования — обеспечить постоянный запуск какого-либо процесса.
чтобы максимизировать загрузку процессора. Цель разделения времени – переключиться
ядро ЦП среди процессов так часто, что пользователи могут взаимодействовать с каждым
программу во время ее работы. Для достижения этих целей планировщик процессов
выбирает доступный процесс (возможно, из набора нескольких доступных процессов)
для выполнения программы на ядре. Каждое ядро ЦП может одновременно запускать один процесс.

ПРЕДСТАВЛЕНИЕ ПРОЦЕССА В LINUX
Блок управления процессом в операционной системе Linux представляет собой
возмущается структурой задачи структуры C, которая находится в
<include/linux/sched.h> включаемый файл в исходный код ядра
каталог. Данная структура содержит всю необходимую информацию для
представление процесса, включая состояние процесса, планирование
информацию об управлении памятью, список открытых файлов и указатели на
родительский процесс и список его дочерних и однородных элементов. (Родитель процесса
это процесс, который его создал; его дети — это любые процессы, которые он создает.
Его братья и сестры являются дочерними элементами одного и того же родительского процесса.) Некоторые из этих полей
включать:
длительное состояние; /* состояние процесса */
структура планирования объекта se; /* информация о расписании */
структура задачи struct *parent; /* родительский процесс */
структура списка головных дочерних элементов; /* дети этого процесса */
структурные файлы struct *files; /* список открытых файлов */
структура мм структура *мм; /* адресное пространство */
Например, состояние процесса представлено полем длинного состояния.
в этой структуре. В ядре Linux представлены все активные процессы.
используя двусвязный список структуры задач. Ядро поддерживает указатель –
текущий – процесс, выполняющийся в данный момент в системе, как показано ниже:

В качестве иллюстрации того, как ядро может манипулировать одним из полей в
структуру задачи для указанного процесса, предположим, что система хочет
чтобы изменить состояние текущего процесса на значение нового состояния.
Если current является указателем на выполняющийся в данный момент процесс, его состояние изменяется.
со следующим:
текущее->состояние = новое состояние;

В системе с одним ядром ЦП никогда не будет более одного процесса.
одновременно работать, тогда как многоядерная система может запускать несколько процессов одновременно
один раз. Если процессов больше, чем ядер, лишним процессам придется ждать, пока ядро освободится и их можно будет перепланировать. Количество процессов
текущий момент в памяти известен как степень мультипрограммирования.
Балансирование целей мультипрограммирования и разделения времени также
требует принятия во внимание общего поведения процесса. В целом, большинство
процессы можно описать как связанные с вводом-выводом или с привязкой к процессору. Привязанность к вводу/выводу
процесс — это процесс, который тратит больше времени на ввод-вывод, чем на выполнение операций
вычисления. Процесс, привязанный к ЦП, напротив, генерирует запросы ввода-вывода.
нечасто, тратя больше времени на вычисления.

3.2.1 Планирование очередей

При поступлении процессов в систему они помещаются в очередь готовности, где и находятся.
готова и ожидает выполнения на ядре ЦП. Эта очередь обычно хранится как
связанный список; заголовок очереди готовности содержит указатели на первую плату в списке,
и каждая плата включает в себя поле указателя, указывающее на следующую плату в готовом виде.
очередь.
Система также включает в себя другие очереди. Когда процессу выделяется процессор
ядро, оно выполняется некоторое время и в конечном итоге завершается, прерывается или ожидает
для возникновения определенного события, такого как завершение ввода-вывода
запрос. Предположим, что процесс отправляет запрос ввода-вывода на такое устройство, как диск.
Поскольку устройства работают значительно медленнее, чем процессоры, процесс будет иметь
дождаться, пока ввод-вывод станет доступным. Процессы, ожидающие определенного
событие, которое должно произойти, например завершение ввода-вывода, помещается в очередь ожидания
(рис. 3.4).
Распространенным представлением планирования процессов является диаграмма очередей.
например, на рисунке 3.5. Присутствуют два типа очередей: очередь готовности и
набор очередей ожидания. Круги обозначают ресурсы, обслуживающие очереди.
а стрелки указывают течение процессов в системе.
Новый процесс изначально помещается в очередь готовности. Он ждет там, пока не
выбран для выполнения или отправлен. Как только процессу будет выделено ядро ЦП
и выполняется, может произойти одно из нескольких событий:

• Процесс может выдать запрос ввода-вывода, а затем перейти в режим ожидания ввода-вывода.
очередь.
• Процесс может создать новый дочерний процесс, а затем перевести его в режим ожидания.
очередь, пока он ожидает завершения дочернего процесса.
• Процесс может быть принудительно удален из ядра в результате
прерывание или истечение его временного интервала и его возвращение в очередь готовности.
В первых двух случаях процесс со временем выходит из состояния ожидания.
в состояние готовности, а затем снова помещается в очередь готовности. Процесс продолжается
этот цикл до тех пор, пока он не завершится, после чего он будет удален из всех очередей и
его печатная плата и ресурсы освобождены.

3.2.2 Планирование ЦП

Процесс перемещается между очередью готовности и различными очередями ожидания через
истекает срок его службы. Роль планировщика ЦП заключается в выборе из числа
процессы, находящиеся в очереди готовности, и выделить ядро ЦП одному из них.
Планировщик ЦП должен часто выбирать новый процесс для ЦП. Ограничение ввода-вывода
процесс может выполняться всего несколько миллисекунд перед ожиданием ввода-вывода
запрос. Несмотря на то, что процесс, связанный с ЦП, потребует ядра ЦП для более длительной работы.
В других случаях планировщик вряд ли предоставит ядро процессу на длительное время.
период. Вместо этого он, вероятно, предназначен для принудительного удаления ЦП из процесса.
и запланировать запуск другого процесса. Таким образом, планировщик ЦП выполняется с
не реже одного раза в 100 миллисекунд, хотя обычно гораздо чаще.
Некоторые операционные системы имеют промежуточную форму планирования, известную как
как обмен, основная идея которого заключается в том, что иногда может быть выгодно
удалить процесс из памяти (и из активной борьбы за процессор)
и тем самым снизить степень мультипрограммирования. В дальнейшем процесс может быть
снова вводится в память, и его выполнение может быть продолжено с того места, где оно было остановлено.
Эта схема известна как подкачка, поскольку процесс можно «выгрузить» из памяти на диск, где сохраняется его текущий статус, а затем «выгрузить» на диск.
с диска обратно в память, где восстанавливается его состояние. Обмен обычно
необходимо только в том случае, если память перегружена и ее необходимо освободить.
Обмен обсуждается в главе 9.

3.2.3 Переключение контекста

Как упоминалось в разделе 1.2.1, прерывания заставляют операционную систему изменяться.
ядро ЦП от его текущей задачи и запустить процедуру ядра. Такие операции
часто случаются в системах общего назначения. При возникновении прерывания
системе необходимо сохранить текущий контекст процесса, выполняющегося на процессоре
ядро, чтобы оно могло восстановить этот контекст после завершения его обработки, по сути
приостановить процесс и затем возобновить его. Контекст представлен в
печатная плата процесса. Он включает в себя значения регистров ЦП, процесс
состояние (см. рис. 3.2) и информацию об управлении памятью. В общем, мы
выполнить сохранение текущего состояния ядра ЦП, будь то в ядре или пользователе
режим, а затем восстановление состояния для возобновления работы.
Переключение ядра ЦП на другой процесс требует выполнения состояния
сохранение текущего процесса и восстановление состояния другого процесса. Этот
Задача известна как переключение контекста и проиллюстрирована на рисунке 3.6. Когда
происходит переключение контекста, ядро сохраняет контекст старого процесса в своем
PCB и загружает сохраненный контекст нового процесса, запланированного к запуску. Контекст-
время переключения — это чистые накладные расходы, поскольку система не выполняет никакой полезной работы, пока
переключение. Скорость переключения варьируется от машины к машине, в зависимости от
скорость памяти, количество регистров, которые необходимо скопировать, и наличие
специальных инструкций (например, одной инструкции для загрузки или сохранения всех регистров).
Типичная скорость составляет несколько микросекунд.

МНОГОЗАДАЧНОСТЬ В МОБИЛЬНЫХ СИСТЕМАХ
Из-за ограничений, налагаемых на мобильные устройства, ранние версии iOS
не обеспечивал многозадачность пользовательского приложения; запустилось только одно приложение
на переднем плане, в то время как все остальные пользовательские приложения были приостановлены. Операционная-
системные задачи были многозадачными, потому что они были написаны Apple и хорошо
вел себя. Однако, начиная с i OS 4, Apple предоставила ограниченную форму
многозадачность пользовательских приложений, что позволяет использовать одно приложение на переднем плане.
возможность запуска одновременно с несколькими фоновыми приложениями. (На
мобильное устройство, приложением на переднем плане является приложение, открытое в данный момент
и появляется на дисплее. Фоновое приложение остается в памяти.
y, но не занимает экран дисплея.) API программирования iOS 4
обеспечил поддержку многозадачности, что позволило процессу выполняться в фоновом режиме.
землю без подвешивания. Однако оно было ограничено и доступно только
для нескольких типов приложений. Как стало предлагаться оборудование для мобильных устройств
больший объем памяти, несколько вычислительных ядер и большее время автономной работы,
последующие версии iOS стали поддерживать более богатый функционал для мульти-
выполнение задач с меньшими ограничениями. Например, больший экран на планшетах iPad.
позволял одновременно запускать два приложения на переднем плане, известный метод
как разделенный экран.
С момента своего появления Android поддерживает многозадачность и не ставит
ограничения на типы приложений, которые могут работать в фоновом режиме. Если
приложение требует обработки в фоновом режиме, приложение
должен использовать службу, отдельный компонент приложения, который запускается от имени
фонового процесса. Рассмотрим приложение потокового аудио: если
приложение переходит в фоновый режим, сервис продолжает отправлять аудио
данные в драйвер аудиоустройства от имени фонового приложения. В
Фактически, служба продолжит работать, даже если фоновое приложение
приостановленный. Сервисы не имеют пользовательского интерфейса и имеют небольшой объем памяти.
занимаемую площадь, обеспечивая тем самым эффективную технику многозадачности на мобильном устройстве.
среда.

Время переключения контекста сильно зависит от аппаратной поддержки. Для
например, некоторые процессоры предоставляют несколько наборов регистров. Переключение контекста
здесь просто требуется изменить указатель на текущий набор регистров. Конечно,
если активных процессов больше, чем наборов регистров, система прибегает к
для копирования данных регистра в память и из памяти, как и раньше. Кроме того, чем более сложный
операционной системы, тем больший объем работы необходимо выполнить во время
переключение контекста. Как мы увидим в главе 9, расширенное управление памятью
методы могут потребовать переключения дополнительных данных с каждым контекстом. Для
Например, адресное пространство текущего процесса должно быть сохранено как
пространство следующей задачи подготовлено к использованию. Как сохраняется адресное пространство,
а какой объем работы нужен для ее сохранения, зависит от памяти-
метод управления операционной системой.

3.3 Операции над процессами

Процессы в большинстве систем могут выполняться одновременно, и их можно создавать.
обновляются и удаляются динамически. Таким образом, эти системы должны обеспечивать механизм
для создания и завершения процесса. В этом разделе мы исследуем механизм
низмы, участвующие в создании процессов, и иллюстрируют создание процессов в UNIX.
и системы Windows.

3.3.1 Создание процесса

В ходе выполнения процесс может создать несколько новых процессов. Как
упоминалось ранее, создающий процесс называется родительским процессом, а новый
процессы называются дочерними элементами этого процесса. Каждый из этих новых процессов
может, в свою очередь, создавать другие процессы, образуя дерево процессов.
Большинство операционных систем (включая UNIX, Linux и Windows) идентифицируют
процессы в соответствии с уникальным идентификатором процесса (или pid), который обычно
целое число. Pid предоставляет уникальное значение для каждого процесса в
системе, и его можно использовать в качестве индекса для доступа к различным атрибутам процесса.
внутри ядра.
Рисунок 3.7 иллюстрирует типичное дерево процессов для операционной системы Linux.
показывая имя каждого процесса и его pid. (Мы используем термин «процесс», а не
в этой ситуации, поскольку Linux предпочитает термин «задача».)
процесс (который всегда имеет pid 1) служит корневым родительским процессом для всех
пользовательские процессы и является первым пользовательским процессом, создаваемым при загрузке системы.
После загрузки системы процесс systemd создает процессы, которые
предоставлять дополнительные услуги, такие как веб-сервер или сервер печати, ssh-сервер и
как. На рисунке 3.7 мы видим двух дочерних элементов systemd — logind и sshd.
Процесс входа в систему отвечает за управление клиентами, которые напрямую входят в систему.
система. В этом примере клиент вошел в систему и использует оболочку bash.
которому присвоен идентификатор pid 8416. Используя интерфейс командной строки bash,
этот пользователь создал процесс ps, а также редактор vim. SSH-процесс
отвечает за управление клиентами, подключающимися к системе с помощью ssh.
(сокращение от Secure Shell).

ПРОЦЕССЫ init И systemd
Традиционные системы UNIX идентифицируют процесс init как корень всех дочерних процессов.
процессы. init (также известному как System V init) назначается pid, равный 1, и он
первый процесс, создаваемый при загрузке системы. На дереве процессов аналогично
к тому, что показано на рисунке 3.7, init находится в корне.
Системы Linux изначально использовали подход инициализации System V, но в последнее время
дистрибутивы заменили его на systemd. Как описано в разделе 3.3.1,
systemd служит начальным процессом системы, почти так же, как System V.
в этом; однако он гораздо более гибок и может предоставлять больше услуг, чем
в этом.

В системах UNIX и Linux мы можем получить список процессов, используя
команда пс. Например, команда

пс -эль

отобразит полную информацию обо всех процессах, активных в данный момент в системе.
Дерево процессов, подобное показанному на рисунке 3.7, можно построить с помощью
рекурсивное отслеживание родительских процессов вплоть до процесса systemd. (В
Кроме того, системы Linux предоставляют команду pstree, которая отображает дерево
всех процессов в системе.)
В общем случае, когда процесс создает дочерний процесс, этот дочерний процесс будет
нужны определенные ресурсы (процессорное время, память, файлы, устройства ввода-вывода) для выполнения
его задача. Дочерний процесс может иметь возможность получать свои ресурсы непосредственно из
операционная система или она может быть ограничена подмножеством ресурсов
родительского процесса. Родителю, возможно, придется разделить свои ресурсы между
его дочерние элементы, или он может иметь возможность совместно использовать некоторые ресурсы (например, память или
файлы) среди нескольких его дочерних элементов. Ограничение дочернего процесса подмножеством
Ресурсы родителя предотвращают перегрузку системы любым процессом путем
создание слишком большого количества дочерних процессов.
Помимо предоставления различных физических и логических ресурсов, родительский
Процесс может передавать данные инициализации (входные данные) дочернему процессу. Для
Например, рассмотрим процесс, функция которого состоит в отображении содержимого файла:
скажем, hw1.c — на экране терминала. Когда процесс будет создан, он получит:
в качестве входных данных родительского процесса имя файла hw1.c. Использование этого файла
имя, он откроет файл и выпишет его содержимое. Он также может получить имя
устройства вывода. Альтернативно, некоторые операционные системы передают ресурсы
дочерние процессы. В такой системе новый процесс может получить два открытых файла:
hw1.c и терминальное устройство и могут просто передавать данные между
два.

Когда процесс создает новый процесс, существуют две возможности его выполнения:
1. Родитель продолжает выполняться одновременно со своими дочерними элементами.
2. Родитель ждет, пока некоторые или все его дочерние элементы завершатся.

Для нового процесса также есть две возможности адресного пространства:
1. Дочерний процесс является дубликатом родительского процесса (имеет тот же
программа и данные в качестве родителя).
2. В дочерний процесс загружена новая программа.

Чтобы проиллюстрировать эти различия, давайте сначала рассмотрим операционную систему UNIX. В
В UNIX, как мы видели, каждый процесс идентифицируется своим идентификатором процесса, который
является уникальным целым числом. Новый процесс создается системным вызовом fork().
новый процесс состоит из копии адресного пространства исходного процесса.
Этот механизм позволяет родительскому процессу легко взаимодействовать со своим дочерним процессом.
процесс. Оба процесса (родительский и дочерний) продолжают выполнение с
инструкция после fork(), с одним отличием: код возврата fork()
равен нулю для нового (дочернего) процесса, тогда как (ненулевой) идентификатор процесса
ребенок возвращается родителю.
После системного вызова fork() один из двух процессов обычно использует
Системный вызов exec() для замены пространства памяти процесса новой про-
грамм. Системный вызов exec() загружает двоичный файл в память (уничтожая
образ памяти программы, содержащей системный вызов exec()) и начинает ее выполнение.
Таким образом, два процесса могут взаимодействовать и
потом разойдутся. Родитель может затем создать больше детей; или, если это
ему больше нечего делать, пока дочерний элемент работает, он может выполнить системный вызов wait()
выйти из очереди готовности до завершения дочернего процесса. Потому что
вызов exec() перекрывает адресное пространство процесса новой программой,
exec() не возвращает управление, пока не произойдет ошибка.

#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
интервал основной()
{
пид т пид;

/* создаем дочерний процесс */
пид = вилка();

if (pid < 0) { /* произошла ошибка */
fprintf(stderr, «Ошибка вилки»);
возврат 1;
}
else if (pid == 0) { /* дочерний процесс */
execlp("/bin/ls","ls",NULL);
}
else { /* родительский процесс */
/* родительский элемент будет ждать завершения дочернего процесса */
подождать (NULL);
printf("Дочерний элемент завершен");
}

вернуть 0;
}

Рисунок 3.8. Создание отдельного процесса с помощью системного вызова UNIX fork().

Программа на языке C, показанная на рис. 3.8, иллюстрирует предварительные системные вызовы UNIX.
жёстко описано. Теперь у нас есть два разных процесса, выполняющих копии
та же программа. Единственное отличие состоит в том, что значение переменной pid для
дочерний процесс равен нулю, а родительский процесс представляет собой целое число, большее, чем
ноль (фактически это фактический pid дочернего процесса). Дочерний процесс наследует
привилегии и атрибуты планирования от родителя, а также определенные ресурсы,
например открытые файлы. Затем дочерний процесс накладывает свое адресное пространство на
Команда UNIX /bin/ls (используется для получения списка каталогов) с помощью execlp()
системный вызов (execlp() — это версия системного вызова exec()). Родитель ждет
чтобы дочерний процесс завершился системным вызовом wait(). Когда ребенок
процесс завершается (путем явного или неявного вызова функции exit()), пар-
ent процесс возобновляется с вызова wait(), где он завершается с использованием
системный вызов exit(). Это также показано на рисунке 3.9.
Конечно, нет ничего, что могло бы помешать ребенку не вызывать exec().
и вместо этого продолжает выполняться как копия родительского процесса. В этом
сценарий, родительский и дочерний процессы являются параллельными процессами, выполняющими один и тот же код
инструкции. Поскольку дочерний процесс является копией родительского, каждый процесс имеет свой собственный
копирование любых данных.
В качестве альтернативного примера мы рассмотрим создание процессов в Windows.
Процессы создаются в Windows API с помощью функции CreateProcess().
tion, который похож на fork() тем, что родительский процесс создает новый дочерний процесс.
Однако, несмотря на то, что fork() имеет дочерний процесс, наследующий адресное пространство
своего родителя, CreateProcess() требует загрузки указанной программы в
адресное пространство дочернего процесса при его создании. Кроме того, тогда как
fork() не передается никаких параметров, CreateProcess() ожидает не менее десяти
параметры.
Программа на языке C, показанная на рис. 3.10, иллюстрирует функцию CreateProcess().
функция, которая создает дочерний процесс, загружающий приложение mspaint.exe.
Мы выбираем многие значения по умолчанию для десяти параметров, передаваемых в Cre-
ateProcess(). Читатели, интересующиеся подробностями создания процесса
и руководству Windows API рекомендуется обратиться к библио-
графические примечания в конце этой главы.
Два параметра, передаваемые в функцию CreateProcess():
экземпляры структур STARTUPINFO и PROCESS INFORMATION.
STARTUPINFO определяет многие свойства нового процесса, например окно
размер и внешний вид, а также дескрипторы стандартных файлов ввода и вывода.
Структура PROCESS INFORMATION содержит дескриптор и идентификаторы для
вновь созданный процесс и его поток. Мы вызываем ZeroMemory().
функция для выделения памяти для каждой из этих структур, прежде чем продолжить
с помощью CreateProcess()

#include <stdio.h>
#include <windows.h>
интервал основной (VOID)
{
СТАРТАПИНФО си;
ИНФОРМАЦИЯ О ПРОЦЕССЕ pi;

/* выделяем память */
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);
ZeroMemory(&pi, sizeof(pi));

/* создаем дочерний процесс */
if (!CreateProcess(NULL, /* использовать командную строку */
"C:∖∖WINDOWS∖∖system32∖∖mspaint.exe", /* команда */
NULL, /* не наследовать дескриптор процесса */
NULL, /* не наследовать дескриптор потока */
ЛОЖЬ, /* отключить наследование дескрипторов */
0, /* флагов создания нет */
NULL, /* использовать родительский блок окружения */
NULL, /* использовать существующий каталог родителя */
&и,
&Пи))
{
fprintf(stderr, «Ошибка создания процесса»);
вернуть -1;
}
/* родительский элемент будет ждать завершения дочернего процесса */
WaitForSingleObject(pi.hProcess, БЕСКОНЕЧНЫЙ);
printf("Дочерний элемент завершен");

/* закрытие дескрипторов */
CloseHandle(pi.hProcess);
CloseHandle(pi.hThread);
}

Рисунок 3.10. Создание отдельного процесса с помощью Windows API.


Первые два параметра, передаваемые в CreateProcess(), представляют собой приложение.
имя и параметры командной строки. Если имя приложения равно NULL (поскольку оно
в данном случае), параметр командной строки указывает загружаемое приложение.
В данном случае мы загружаем приложение Microsoft Windows mspaint.exe.
катион. Помимо этих двух начальных параметров, мы используем параметры по умолчанию для
наследование дескрипторов процессов и потоков, а также указание, что не будет
флаги создания. Мы также используем существующий блок окружения родителя и запускаем
каталог. Наконец, мы предоставляем два указателя на STARTUPINFO и PROCESS:
ИНФОРМАЦИОННЫЕ структуры, созданные в начале программы. На рисунке
3.8 родительский процесс ожидает завершения дочернего процесса, вызывая wait().
системный вызов. Эквивалентом этого в Windows является WaitForSingleObject(),
которому передается дескриптор дочернего процесса — pi.hProcess — и он ожидает
этот процесс завершить. После завершения дочернего процесса управление возвращается из
Функция WaitForSingleObject() в родительском процессе.
3.3.2 Завершение процесса
Процесс завершается, когда он завершает выполнение своего последнего оператора и запрашивает
операционную систему, чтобы удалить его с помощью системного вызова exit(). При этом
В этот момент процесс может вернуть значение статуса (обычно целое число) своему ожидающему
родительский процесс (через системный вызов wait()). Все ресурсы процесса
— включая физическую и виртуальную память, открытые файлы и буферы ввода-вывода —
освобождены и восстановлены операционной системой.
Расторжение договора может произойти и при других обстоятельствах. Процесс может вызвать
завершение другого процесса посредством соответствующего системного вызова (например,
TerminateProcess() в Windows). Обычно такой системный вызов можно вызвать
только родителем процесса, который должен быть завершен. В противном случае пользователь—
или неправильно работающее приложение — может произвольно завершить процессы другого пользователя.
Обратите внимание, что родительскому элементу необходимо знать личности своих дочерних элементов, если он хочет прекратить действие.
их. Таким образом, когда один процесс создает новый процесс, личность нового процесса
созданный процесс передается родителю.
Родитель может прекратить выполнение одного из своих дочерних элементов по ряду причин.
причины, например такие:
• Ребенок превысил использование некоторых ресурсов, которые ему были предоставлены.
выделено. (Чтобы определить, произошло ли это, родитель должен иметь
механизм проверки состояния дочерних элементов.)
• Задача, назначенная ребенку, больше не требуется.
• Родительский элемент завершает работу, а операционная система не позволяет дочернему элементу
продолжить, если его родительский элемент завершает работу.
Некоторые системы не позволяют дочернему элементу существовать, если его родительский элемент прекратил существование.
В таких системах, если процесс завершается (нормально или ненормально), то
все его дочерние элементы также должны быть прекращены. Это явление, получившее название
каскадное завершение обычно инициируется операционной системой.
Чтобы проиллюстрировать выполнение и завершение процесса, учтите, что в Linux и
В системах UNIX мы можем завершить процесс, используя системный вызов exit():
предоставление статуса выхода в качестве параметра:

/* выход со статусом 1 */
выход (1);

Фактически, при обычном завершении функция exit() будет вызываться либо напрямую (как
как показано выше) или косвенно, как библиотека времени выполнения C (которая добавляется в UNIX
исполняемые файлы) по умолчанию будет включать вызов exit().
Родительский процесс может дождаться завершения дочернего процесса, используя
системный вызов wait(). Системному вызову wait() передается параметр, который
позволяет родителю получить статус выхода дочернего элемента. Этот системный вызов также
возвращает идентификатор процесса завершенного дочернего процесса, чтобы родитель мог сказать
какой из его детей завершился:

пид т пид;
международный статус;

pid = ожидание (& статус);

Когда процесс завершается, его ресурсы освобождаются операционной системой.
система. Однако его запись в таблице процессов должна оставаться там до тех пор, пока не будет
родитель вызывает wait(), поскольку таблица процессов содержит статус завершения процесса.
Процесс, который завершился, но родитель которого еще не вызвал функцию wait(), называется
известный как зомби-процесс. Все процессы переходят в это состояние, когда они
прекращаются, но обычно они существуют как зомби лишь непродолжительное время. Как только родитель
вызывает wait(), идентификатор процесса-зомби и его запись в
таблица процессов освобождена.
Теперь представьте, что произойдет, если родитель не вызовет wait() и
вместо этого завершается, тем самым оставляя дочерние процессы сиротами. Традиционный
Системы UNIX решили этот сценарий, назначив процесс init новым
родительские процессы-сироты. (Вспомните раздел 3.3.1, что init служит
корень иерархии процессов в системах UNIX.) Процесс init периодически
вызывает wait(), тем самым позволяя определить статус завершения любого потерянного процесса.
собирает и освобождает идентификатор потерянного процесса и запись таблицы процессов.
Хотя в большинстве систем Linux init заменен на systemd, последний
процесс все еще может выполнять ту же роль, хотя Linux также позволяет процессам и другие
чем systemd для наследования потерянных процессов и управления их завершением.

3.3.2.1 Иерархия процессов Android

Из-за ограничений ресурсов, таких как ограниченная память, мобильная работа
системам, возможно, придется завершить существующие процессы, чтобы вернуть ограниченную систему
Ресурсы. Вместо завершения произвольного процесса Android определил
иерархия важности процессов и когда система должна завершить работу
процесс предоставления ресурсов для нового или более важного процесса,
он завершает процессы в порядке возрастания важности. От большего к меньшему
Важно отметить, что иерархия классификаций процессов выглядит следующим образом:
• Процесс на переднем плане — текущий процесс, видимый на экране, представляет собой
запуск приложения, с которым пользователь в данный момент взаимодействует
• Видимый процесс — процесс, который не виден непосредственно на переднем плане.
но это выполнение действия, на которое ссылается процесс переднего плана
к (то есть процессу, выполняющему действие, статус которого отображается на
процесс на переднем плане)
• Процесс обслуживания — процесс, аналогичный фоновому процессу, но
выполняет действие, очевидное для пользователя (например, потоковую передачу
музыка)
• Фоновый процесс — процесс, который может выполнять действие, но
не является очевидным для пользователя.
• Пустой процесс — процесс, который не содержит связанных с ним активных компонентов.
с любым приложением
Если системные ресурсы необходимо вернуть, Android сначала завершится пустым
процессы, за которыми следуют фоновые процессы и т. д. Процессы
присвоен рейтинг важности, и Android пытается назначить процесс как
максимально высокий рейтинг. Например, если процесс предоставляет услугу и
также виден, ему будет присвоен более важный видимый класс.
Кроме того, практика разработки Android предполагает следование руководству:
линии жизненного цикла процесса. При соблюдении этих рекомендаций состояние
процесс будет сохранен до завершения и возобновлен в сохраненном состоянии, если
пользователь возвращается в приложение.

3.4 Межпроцессное взаимодействие

Процессы, выполняющиеся одновременно в операционной системе, могут быть либо независимыми, либо
ожидающие процессы или взаимодействующие процессы. Процесс является независимым, если он выполняет
не передавать данные другим процессам, выполняющимся в системе. Процесс
сотрудничает, если оно может повлиять или подвергнуться воздействию других выполняющихся процессов
в системе. Очевидно, что любой процесс, который обменивается данными с другими процессами, является
процесс сотрудничества.
Существует несколько причин для создания среды, позволяющей процессу
сотрудничество:
• Обмен информацией. Поскольку несколько приложений могут быть заинтересованы в
одну и ту же информацию (например, копирование и вставка), мы должны
обеспечить среду, позволяющую одновременный доступ к такой информации.
• Ускорение вычислений. Если мы хотим, чтобы конкретная задача выполнялась быстрее, мы должны
разбейте его на подзадачи, каждая из которых будет выполняться параллельно с
другие. Заметьте, что такого ускорения можно добиться только в том случае, если компьютер
имеет несколько вычислительных ядер.
• Модульность. Возможно, мы захотим построить систему по модульному принципу,
разделение системных функций на отдельные процессы или потоки, поскольку мы
обсуждается в главе 2.
Взаимодействующие процессы требуют межпроцессного взаимодействия (IPC).
механизм, который позволит им обмениваться данными, то есть отправлять данные
и получать данные друг от друга. Существуют две фундаментальные модели
межпроцессное взаимодействие: общая память и передача сообщений. в
модель общей памяти, область памяти, которая используется совместно сотрудничающими
процессы установлены. Затем процессы могут обмениваться информацией, читая
и запись данных в общий регион. В модели передачи сообщений
общение происходит посредством сообщений, которыми обмениваются
взаимодействующие процессы. Две коммуникационные модели противопоставляются
Рисунок 3.11.

МНОГОПРОЦЕССНАЯ АРХИТЕКТУРА — БРАУЗЕР Chrome
Многие веб-сайты содержат активный контент, такой как JavaScript, Flash и HTML5.
чтобы обеспечить богатый и динамичный опыт просмотра веб-страниц. К сожалению,
эти веб-приложения также могут содержать программные ошибки, которые могут привести к
медленное время отклика и может даже привести к сбою веб-браузера. Этот
не является большой проблемой для веб-браузера, который отображает контент только с одного веб-сайта.
сайт. Но большинство современных веб-браузеров поддерживают просмотр с вкладками, что
позволяет одному экземпляру приложения веб-браузера открывать несколько веб-сайтов
при этом каждый сайт в отдельной вкладке. Для переключения между диф-
На многих сайтах пользователю достаточно нажать на соответствующую вкладку. Эта договоренность
показано ниже:
Проблема с этим подходом заключается в том, что если веб-приложение на любой вкладке выходит из строя,
весь процесс, включая все остальные вкладки, отображающие дополнительные веб-сайты,
также вылетает.
Веб-браузер Google Chrome был разработан для решения этой проблемы.
использование многопроцессной архитектуры. Chrome различает три разных типа
процессы: браузер, средства визуализации и плагины.
• Процесс браузера отвечает за управление пользовательским интерфейсом как
а также дисковый и сетевой ввод-вывод. Новый процесс браузера создается, когда
Хром запускается. Создается только один процесс браузера.
• Процессы рендеринга содержат логику для рендеринга веб-страниц. Таким образом, они
содержат логику для обработки HTML, Javascript, изображений и т. д. Как
общее правило: новый процесс рендеринга создается для каждого открытого веб-сайта.
на новой вкладке, поэтому одновременно могут быть активны несколько процессов рендеринга
время.
• Процесс создания плагина создается для каждого типа плагина (например, Flash или
QuickTime) используется. Процессы плагина содержат код плагина в виде
а также дополнительный код, который позволяет плагину взаимодействовать с
связанные процессы рендеринга и процесс браузера.
Преимущество многопроцессного подхода заключается в том, что веб-сайты работают изолированно.
связь друг с другом. Если один веб-сайт выходит из строя, срабатывает только процесс его рендеринга.
затронутый; все остальные процессы остаются нетронутыми. Кроме того, рендерер про-
процессы выполняются в «песочнице», что означает, что доступ к диску и сетевому вводу-выводу ограничен.
ограничено, сводя к минимуму последствия любых эксплойтов безопасности.

Обе только что упомянутые модели распространены в операционных системах.
и многие системы реализуют оба. Передача сообщений полезна для обмена
меньшие объемы данных, поскольку не нужно избегать конфликтов. Проход сообщения-
Кроме того, ing проще реализовать в распределенной системе, чем в общей памяти.
(Хотя существуют системы, предоставляющие распределенную общую память, мы это делаем.
не рассматривайте их в этом тексте.) Общая память может работать быстрее, чем передача сообщений.
ing, поскольку системы передачи сообщений обычно реализуются с использованием system
вызовы и, следовательно, требуют более трудоемкой задачи вмешательства ядра.
В системах с общей памятью системные вызовы требуются только для установления общей памяти.
области памяти. После создания общей памяти все обращения обрабатываются.
как обычный доступ к памяти, и никакой помощи со стороны ядра не требуется.
В разделах 3.5 и 3.6 мы исследуем разделяемую память и обмен сообщениями.
системы прохождения более подробно.

3.5 IPC в системах с общей памятью

Межпроцессное взаимодействие с использованием общей памяти требует взаимодействия
процессы для создания области общей памяти. Обычно общая память
регион находится в адресном пространстве процесса, создающего общую память.
сегмент. Другие процессы, желающие взаимодействовать с использованием этой общей памяти.
сегмент должен прикрепить его к своему адресному пространству. Напомним, что обычно оператор
система пытается предотвратить доступ одного процесса к другому процессу.
Память. Общая память требует, чтобы два или более процесса согласились удалить
это ограничение. Затем они могут обмениваться информацией, читая и записывая.
данные в общих областях. Форма данных и расположение определяются
этими процессами и не находятся под контролем операционной системы. Про-
цессы также несут ответственность за то, чтобы они не писали в один и тот же адрес.
местоположение одновременно.

Чтобы проиллюстрировать концепцию взаимодействующих процессов, давайте рассмотрим
проблема производителя-потребителя, которая является общей парадигмой для сотрудничества производителей.
уступки. Процесс-производитель производит информацию, которая потребляется кон-
Шумерский процесс. Например, компилятор может создать ассемблерный код, который
потребляется ассемблером. Ассемблер, в свою очередь, может создавать модификации объекта.
ules, которые используются загрузчиком. Проблема производителя и потребителя также
представляет собой полезную метафору парадигмы клиент-сервер. Мы обычно думаем
сервера как производителя и клиента как потребителя. Например, веб-сервер
создает (то есть предоставляет) веб-контент, такой как HTML-файлы и изображения, которые
потребляются (то есть читаются) клиентским веб-браузером, запрашивающим ресурс.
Одним из решений проблемы производитель-потребитель является использование общей памяти. К
позволить процессам производителя и потребителя работать одновременно, мы должны иметь
доступен буфер элементов, который может быть заполнен производителем и очищен
потребитель. Этот буфер будет находиться в области памяти, которая используется совместно
Процессы производителя и потребителя. Производитель может производить один товар, пока
потребитель потребляет другой товар. Производитель и потребитель должны быть
синхронизированы, чтобы потребитель не пытался использовать предмет, который
еще не производился.
Можно использовать два типа буферов. Неограниченный буфер не накладывает никаких практик.
тическое ограничение на размер буфера. Потребителю, возможно, придется ждать новых
предметы, но производитель всегда может производить новые предметы. Ограниченный буфер
предполагает фиксированный размер буфера. В этом случае потребитель должен дождаться, если буфер
пуст, и производитель должен ждать, если буфер заполнен.
Давайте более внимательно посмотрим, как ограниченный буфер иллюстрирует межпроцессный процесс.
общение с использованием общей памяти. Следующие переменные находятся в
область памяти, совместно используемая процессами производителя и потребителя:

#define РАЗМЕР БУФЕРА 10
typedef структура {
. . .
} элемент;

буфер элемента [РАЗМЕР БУФЕРА];
интервал в = 0;
интервал выхода = 0;

Общий буфер реализован как кольцевой массив с двумя логическими указателями:
и из. Переменная in указывает на следующую свободную позицию в буфере; вне
указывает на первую полную позицию в буфере. Буфер пуст, когда ==
вне; буфер полон, когда ((in + 1) % РАЗМЕР БУФЕРА) == out.
Код процесса-производителя показан на рис. 3.12, а код процесса-производителя показан на рис. 3.12.
потребительский процесс показан на рисунке 3.13. Процесс производителя имеет локальный
переменная, следующая произведенная, в которой хранится новый элемент, который будет произведен.
Потребительский процесс имеет локальную переменную, в которой затем будет использован элемент, который будет
потребленное сохраняется.
Эта схема допускает не более РАЗМЕР БУФЕРА — 1 элемент в буфере в момент
в то же время. Мы оставляем это в качестве упражнения, чтобы вы могли найти решение, в котором
Элементы BUFFER SIZE могут находиться в буфере одновременно. В разделе 3.7.1 мы
проиллюстрируйте POSIX API для общей памяти.

следующий произведенный товар;
в то время как (истина) {
/* произвести элемент в следующем произведении */
while (((вход + 1) % РАЗМЕР БУФЕРА) == выход)
; /* ничего не делать */
буфер[in] = следующий произведенный;
in = (in + 1) % РАЗМЕР БУФЕРА;
}

Рисунок 3.12. Процесс-производитель, использующий общую память.


Одна из проблем, которую не затрагивает эта иллюстрация, касается ситуации, в которой
и процесс-производитель, и процесс-потребитель пытаются получить доступ к
общий буфер одновременно. В главах 6 и 7 мы обсуждаем, как синхронизировать
хронизация взаимодействующих процессов может быть эффективно реализована в
среда с общей памятью.
3.6 IPC в системах передачи сообщений
В разделе 3.5 мы показали, как взаимодействующие процессы могут взаимодействовать в
среда с общей памятью. Схема требует, чтобы эти процессы имели общий
область памяти и что код для доступа к общей памяти и управления ею
память должна быть записана непосредственно прикладным программистом. Еще один способ
достижения того же эффекта заключается в том, что операционная система предоставляет средства для
взаимодействующие процессы для связи друг с другом посредством передачи сообщений
средство.

предмет, который будет использован следующим;
в то время как (истина) {
пока (вход == выход)
; /* ничего не делать */

следующий потребляемый = буфер [выход];
out = (out + 1) % РАЗМЕР БУФЕРА;

/* потребляем предмет при следующем потреблении */
}

Рисунок 3.13. Процесс-потребитель, использующий общую память.

Передача сообщений обеспечивает механизм, позволяющий процессам взаимодействовать.
и синхронизировать свои действия, не используя одно и то же адресное пространство. Это
особенно полезно в распределенной среде, где обмен данными
процессы могут находиться на разных компьютерах, подключенных к сети. Для
Например, программа интернет-чата может быть разработана таким образом, чтобы участники чата
общаться друг с другом путем обмена сообщениями.
Средство передачи сообщений обеспечивает как минимум две операции:

Отправить сообщение)
и
получить (сообщение)

Сообщения, отправляемые процессом, могут иметь фиксированный или переменный размер. Если только
можно отправлять сообщения фиксированного размера, реализация на системном уровне проста.
вперед. Однако это ограничение делает задачу программирования более сложной.
культ. И наоборот, сообщения переменного размера требуют более сложного системного уровня.
реализации, но задача программирования становится проще. Это обычное дело
своего рода компромисс, наблюдаемый при проектировании операционной системы.
Если процессы P и Q хотят взаимодействовать, они должны отправлять сообщения и
получать сообщения друг от друга: между
их. Эту ссылку можно реализовать разными способами. Мы обеспокоены здесь
не с физической реализацией канала (например, с общей памятью, аппаратным обеспечением).
шину или сеть, которые рассматриваются в главе 19), а скорее с ее логическими
выполнение. Вот несколько методов логической реализации ссылки
и операции send()/receive():

• Прямое или косвенное общение
• Синхронная или асинхронная связь
• Автоматическая или явная буферизация.

Далее мы рассмотрим проблемы, связанные с каждой из этих функций.

3.6.1 Мы

Процессы, которые хотят взаимодействовать, должны иметь возможность ссылаться друг на друга.
Они могут использовать как прямое, так и косвенное общение.
При прямом общении каждый процесс, желающий взаимодействовать
необходимо явно указать получателя или отправителя сообщения. В этом
В схеме примитивы send() и получения() определяются как:
• send(P, message) — отправить сообщение для обработки P.
• get(Q, message) — получить сообщение от процесса Q.
Канал связи в этой схеме имеет следующие свойства:
• Связь устанавливается автоматически между каждой парой процессов, которые
хочу общаться. Процессы должны знать только друг друга
личность для общения.

• Ссылка связана ровно с двумя процессами.
• Между каждой парой процессов существует ровно одно соединение.

Эта схема демонстрирует симметрию адресации; то есть оба отправителя про-
cess, и процесс-получатель должен назвать другой для связи. Вариант
В этой схеме используется асимметрия адресации. Здесь только имена отправителей
получатель; получатель не обязан называть отправителя. В этой схеме
Примитивы send() и получения() определяются следующим образом:

• send(P, message) — отправить сообщение для обработки P.
• получения(id, сообщение) — получить сообщение от любого процесса. Вари-
Идентификатор возможности установлен на имя процесса, с которым установлена связь.
состоялось.

Недостаток обеих этих схем (симметричной и несимметричной)
является ограниченная модульность результирующих определений процессов. Изменение
идентификатор процесса может потребовать изучения всех других определений процесса.
Все ссылки на старый идентификатор должны быть найдены, чтобы их можно было изменить.
к новому идентификатору. В общем, любые подобные методы жесткого кодирования, где
методы, которые должны быть четко указаны, менее желательны, чем методы, включающие
косвенность, как описано далее.
При непрямой связи сообщения отправляются и принимаются от
почтовые ящики или порты. Почтовый ящик можно рассматривать абстрактно как объект,
какие сообщения могут размещаться процессами и из каких сообщений могут
удалить. Каждый почтовый ящик имеет уникальный идентификатор. Например, POSIX
очереди сообщений используют целочисленное значение для идентификации почтового ящика. Процесс может ком-
общаться с другим процессом через несколько разных почтовых ящиков, но два
процессы могут взаимодействовать только в том случае, если у них есть общий почтовый ящик. Отправить()
и примитивы получения() определяются следующим образом:
• send(A, message) — отправить сообщение в почтовый ящик A.
• get(A, message) — получить сообщение из почтового ящика A.

В этой схеме канал связи имеет следующие свойства:

• Связь между парой процессов устанавливается только в том случае, если оба участника
у пары есть общий почтовый ящик.
• Ссылка может быть связана с более чем двумя процессами.
• Между каждой парой взаимодействующих процессов существует ряд различных связей.
может существовать, где каждая ссылка соответствует одному почтовому ящику.

Теперь предположим, что процессы P1, P2 и P3 используют общий почтовый ящик A. Процесс P1
отправляет сообщение A, в то время как P2 и P3 выполняют метод получения() от A.
процесс получит сообщение, отправленное P1? Ответ зависит от того, какой из
следующие методы, которые мы выбираем:

• Разрешить связывание ссылки максимум с двумя процессами.
• Разрешить не более одному процессу одновременно выполнять операцию получения().
• Разрешить системе произвольно выбирать, какой процесс будет получать сообщение.
sage (то есть либо P2, либо P3, но не оба, получат сообщение).
система может определить алгоритм выбора процесса, который получит
сообщение (например, циклический алгоритм, при котором процессы по очереди получают
прослушивание сообщений). Система может идентифицировать получателя для отправителя.

Почтовый ящик может принадлежать либо процессу, либо операционной системе.
Если почтовый ящик принадлежит процессу (то есть почтовый ящик является частью адреса
пространстве процесса), то мы различаем владельца (который может
получать сообщения только через этот почтовый ящик) и пользователя (который может только
отправлять сообщения в почтовый ящик). Поскольку у каждого почтового ящика есть уникальный владелец, существует
не может быть никакой путаницы относительно того, какой процесс должен получить сообщение, отправленное
этот почтовый ящик. Когда процесс, владеющий почтовым ящиком, завершается, почтовый ящик
исчезает. Любой процесс, который впоследствии отправляет сообщение в этот почтовый ящик.
должен быть уведомлен о том, что почтовый ящик больше не существует.
Напротив, почтовый ящик, принадлежащий операционной системе, имеет существующую
напряжено само по себе. Он независим и не привязан к какому-либо конкретному процессу.
В этом случае операционная система должна предоставить механизм, позволяющий процессу
сделайте следующее:

• Создайте новый почтовый ящик.
• Отправлять и получать сообщения через почтовый ящик.
• Удалить почтовый ящик.

Процесс создания нового почтового ящика по умолчанию является владельцем этого почтового ящика.
Изначально владелец — единственный процесс, который может получать сообщения через этот
почтовый ящик. Однако право собственности и привилегия получения могут быть переданы
другие процессы посредством соответствующих системных вызовов. Конечно, это положение
может привести к появлению нескольких получателей для каждого почтового ящика.

3.6.2 Синхронизация

Связь между процессами осуществляется посредством вызовов send() и
Примитивы получения(). Существуют различные варианты реализации конструкции.
каждый примитив. Передача сообщений может быть как блокирующей, так и неблокирующей.
также известный как синхронный и асинхронный. (На протяжении всего этого текста вы будете
столкнуться с понятиями синхронного и асинхронного поведения по отношению
к различным алгоритмам операционной системы.)
• Блокировка отправки. Процесс отправки блокируется до тех пор, пока сообщение не будет
получено принимающим процессом или почтовым ящиком.
• Неблокирующая отправка. Процесс отправки отправляет сообщение и возобновляется.
операция.
• Блокировка приема. Получатель блокируется до тех пор, пока сообщение не станет доступным.
• Неблокирующий прием. Получатель получает либо допустимое сообщение, либо
нулевой.

следующее сообщение;

в то время как (истина) {
/* произвести элемент в следующем произведении */

отправить (следующий произведенный);
}

Рисунок 3.14. Процесс производителя, использующий передачу сообщений.


Возможны различные комбинации send() и получения(). Когда оба
send() и получения() блокируются, у нас есть рандеву между
отправитель и получатель. Решение проблемы производитель-потребитель
становится тривиальным, когда мы используем блокирующие операторы send() и получения().
производитель просто вызывает блокирующий вызов send() и ждет, пока сообщение
доставляется получателю или почтовому ящику. Аналогично, когда потребитель
вызывает метод получения(), он блокируется до тех пор, пока сообщение не станет доступным. Это проиллюстрировано в
Рисунки 3.14 и 3.15.

3.6.3 Буферизация

Независимо от того, является ли общение прямым или косвенным, сообщения, которыми обмениваются
Процессы связи находятся во временной очереди. В принципе, такие очереди могут быть
реализуется тремя способами:

• Нулевая мощность. Очередь имеет максимальную длину, равную нулю; таким образом, ссылка
в нем не может быть ожидающих сообщений. В этом случае отправитель должен заблокировать
до тех пор, пока получатель не получит сообщение.
• Ограниченная мощность. Очередь имеет конечную длину n; таким образом, не более n сообщений
может проживать в нем. Если очередь не заполнена при отправке нового сообщения,
сообщение помещается в очередь (либо сообщение копируется, либо указатель
сообщение сохраняется), и отправитель может продолжить выполнение без
ожидающий. Однако пропускная способность канала ограничена. Если ссылка заполнена, отправитель
должен блокироваться до тех пор, пока в очереди не освободится место.
• Неограниченная мощность. Длина очереди потенциально бесконечна; таким образом, любой
количество сообщений может ожидать в нем. Отправитель никогда не блокируется.
Случай с нулевой пропускной способностью иногда называют системой сообщений без
буферизация. Остальные случаи называются системами с автоматической буферизацией.

Случай с нулевой пропускной способностью иногда называют системой сообщений без
буферизация. Остальные случаи называются системами с автоматической буферизацией.

следующее использованное сообщение;

в то время как (истина) {
получить (следующий потребляемый);
/* потребляем предмет при следующем потреблении */
}

Рисунок 3.15. Процесс-потребитель, использующий передачу сообщений.

3.7 Примеры систем IPC

В этом разделе мы рассмотрим четыре различные системы IPC. Сначала мы рассмотрим POSIX
API для общей памяти, а затем обсудим передачу сообщений в операционной системе Mach.
система питания. Далее мы представляем Windows IPC, которая интересно использует общий
память как механизм обеспечения определенных типов передачи сообщений. Мы
завершаются каналами — одним из первых механизмов IPC в системах UNIX.

3.7.1 Общая память POSIX

Для систем POSIX доступно несколько механизмов IPC, включая общий
память и передача сообщений. Здесь мы исследуем POSIX API для общих
Память.
Общая память POSIX организована с помощью отображенных в памяти файлов, которые
связать область общей памяти с файлом. Процесс должен сначала создать
объект общей памяти с помощью системного вызова shm open() следующим образом:

fd = shm open(name, O CREAT | O RDWR, 0666);

Первый параметр указывает имя объекта общей памяти. Процессы
желающие получить доступ к этой общей памяти должны обратиться к объекту по этому имени.
Последующие параметры указывают, что объект общей памяти должен быть создан.
если он еще не существует (СОЗДАТЬ) и объект открыт для чтения и
письмо (О RDWR). Последний параметр устанавливает права доступа к файлам
объект общей памяти. Успешный вызов shm open() возвращает целое число.
файловый дескриптор объекта общей памяти.
Как только объект установлен, функция ftruncate() используется для
настроить размер объекта в байтах. Вызов

ftruncate(ФД, 4096);

устанавливает размер объекта в 4096 байт.
Наконец, функция mmap() создает отображенный в памяти файл, содержащий
объект общей памяти. Он также возвращает указатель на файл, отображенный в памяти.
который используется для доступа к объекту общей памяти.
Программы, показанные на рисунках 3.16 и 3.17, используют производителя –
потребительская модель реализации общей памяти. Производитель устанавливает
объект общей памяти и записывает в общую память, а потребитель читает
из общей памяти.

#include <stdio.h>
#include <stdlib.h>
#include <строка.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>

#include <sys/mman.h>

интервал основной()
{
/* размер (в байтах) объекта общей памяти */
константный INT РАЗМЕР = 4096;
/* имя объекта общей памяти */
const char *name = "ОС";
/* строки, записываемые в общую память */
const char *message 0 = «Привет»;
const char *message 1 = "Мир!";

/* дескриптор файла общей памяти */
интервал ФД;
/* указатель на объект общей памяти */
символ *ptr;

/* создаем объект общей памяти */
fd = shm open(name,O CREAT | O RDWR,0666);

/* настраиваем размер объекта общей памяти */
ftruncate(ФД, РАЗМЕР);

/* сопоставляем память с объектом общей памяти */
ПТР = (символ *)
mmap(0, SIZE, PROT READ | PROT WRITE, MAP SHARED, fd, 0);

/* запись в объект общей памяти */
sprintf(ptr,"%s",сообщение 0);
ptr += strlen(сообщение 0);
sprintf(ptr,"%s",сообщение 1);
ptr += strlen(сообщение 1);

вернуть 0;
}

Рисунок 3.16. Процесс производителя, иллюстрирующий API общей памяти POSIX.

Производитель, показанный на рисунке 3.16, создает объект общей памяти с именем
ОС и пишет печально известную строку «Hello World!» в общую память.
программа отображает в памяти объект общей памяти указанного размера и
позволяет писать в объект. Флаг MAP SHARED указывает, что изменяется
Объект общей памяти будет виден всем процессам, использующим этот объект. Уведомление
что мы записываем в объект общей памяти, вызывая функцию sprintf()
и записываем отформатированную строку в указатель ptr. После каждой записи мы должны
увеличить указатель на количество записанных байт.

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>

#include <sys/mman.h>

интервал основной()
{
/* размер (в байтах) объекта общей памяти */
константный INT РАЗМЕР = 4096;
/* имя объекта общей памяти */
const char *name = "ОС";
/* дескриптор файла общей памяти */
интервал ФД;
/* указатель на объект общей памяти */
символ *ptr;

/* открываем объект общей памяти */
fd = shm open(name, O RDONLY, 0666);

/* сопоставляем память с объектом общей памяти */
ПТР = (символ *)
mmap(0, SIZE, PROT READ | PROT WRITE, MAP SHARED, fd, 0);

/* чтение из объекта общей памяти */
printf("%s",(char *)ptr);

/* удаляем объект общей памяти */
шм отсоединить (имя);

вернуть 0;
}

Рисунок 3.17. Потребительский процесс, иллюстрирующий API общей памяти POSIX.

Процесс-потребитель, показанный на рисунке 3.17, считывает и выводит данные.
палатки общей памяти. Потребитель также вызывает shm unlink().
функция, которая удаляет сегмент общей памяти после того, как потребитель
получил к нему доступ. Мы предоставляем дополнительные упражнения с использованием API общей памяти POSIX в
упражнения по программированию в конце этой главы. Дополнительно мы предоставляем
более подробное описание отображения памяти содержится в разделе 13.5.

3.7.2 Передача сообщения Маха

В качестве примера передачи сообщений мы далее рассмотрим работу Маха.
система. Мах был специально разработан для распределенных систем, но был показан
быть подходящим для настольных и мобильных систем, о чем свидетельствует его
включение в операционные системы Mac OS и i OS, как обсуждалось в главе 2.
Ядро Mach поддерживает создание и уничтожение нескольких задач.
которые похожи на процессы, но имеют несколько потоков управления и
меньше связанных ресурсов. Большая часть сообщений на Маха, включая все меж-
коммуникация задачи — осуществляется посредством сообщений. Сообщения отправляются и
полученные из почтовых ящиков, которые на Маха называются портами. Порты имеют конечный размер
и однонаправленный; при двусторонней связи сообщение отправляется на один порт,
и ответ отправляется на отдельный порт ответа. Каждый порт может иметь несколько
отправители, но только один получатель. Mach использует порты для представления таких ресурсов, как
как задачи, потоки, память и процессоры, а передача сообщений обеспечивает
объектно-ориентированный подход для взаимодействия с этими системными ресурсами и
услуги. Передача сообщений может происходить между любыми двумя портами на одном хосте.
или на отдельных хостах в распределенной системе.
С каждым портом связан набор прав порта, которые идентифицируют
возможности, необходимые задаче для взаимодействия с портом. Например,
чтобы задача получила сообщение из порта, она должна иметь возможность
MAC PORT RIGHT RECEIVE для этого порта. Задача создания порта заключается в том, что
владелец порта, а владелец — единственная задача, которой разрешено получать сообщения
из этого порта. Владелец порта также может манипулировать возможностями порта.
Чаще всего это делается при установке ответного порта. Например, предположим
что задача T1 владеет портом P1 и отправляет сообщение на порт P2, который принадлежит
по задаче Т2. Если T1 ожидает получить ответ от T2, он должен предоставить T2
правый MACH PORT RIGHT SEND для порта P1. Право собственности на порт находится в
уровень задачи, что означает, что все потоки, принадлежащие одной задаче, совместно используют
те же права порта. Таким образом, два потока, принадлежащие одной и той же задаче, могут легко
общаться путем обмена сообщениями через порт каждого потока, связанный
с каждой нитью.
При создании задачи два специальных порта — порт Task Self и порт
Notify port — также создаются. Ядро получило права на Task Self
порт, который позволяет задаче отправлять сообщения ядру. Ядро может отправлять
уведомление о возникновении событий на порт Notify задачи (куда, конечно же,
задача имеет права на получение).
Вызов функции mach port allocate() создает новый порт и выделяет
место для очереди сообщений. Он также определяет права на порт. Каждый
Право порта представляет имя этого порта, и доступ к порту возможен только через
право. Имена портов представляют собой простые целочисленные значения и ведут себя так же, как файлы UNIX.
дескрипторы. Следующий пример иллюстрирует создание порта с использованием этого API:

Маха порта t порта; // имя порта справа

выделить мах-порт(
mach Task self(), // задача, ссылающаяся на себя
MACH PORT RIGHT RECEIVE, // права для этого порта
&порт); // имя порта справа

Каждая задача также имеет доступ к порту начальной загрузки, который позволяет задаче регистрироваться.
порт, созданный с помощью общесистемного сервера начальной загрузки. Как только порт был
зарегистрирован на загрузочном сервере, другие задачи могут искать порт в этом
реестр и получить права на отправку сообщений в порт.
Очередь, связанная с каждым портом, имеет конечный размер и изначально пуста.
Когда сообщения отправляются в порт, они копируются в очередь. Все
Сообщения доставляются надежно и имеют одинаковый приоритет. Мах гарантирует
что несколько сообщений от одного и того же отправителя ставятся в очередь в порядке очереди.
out (FIFO), но не гарантирует абсолютную упорядоченность. Например,
сообщения от двух отправителей могут быть поставлены в очередь в любом порядке.
Сообщения Маха содержат следующие два поля:

• Заголовок сообщения фиксированного размера, содержащий метаданные о сообщении.
включая размер сообщения, а также порты источника и назначения.
Обычно отправляющий поток ожидает ответа, поэтому имя порта
источник передается принимающей задаче, которая может использовать его как «возвратный»
адрес» при отправке ответа.
• Тело переменного размера, содержащее данные.

Сообщения могут быть простыми или сложными. Простое сообщение содержит
обычные, неструктурированные пользовательские данные, не интерпретируемые ядром. А
сложное сообщение может содержать указатели на ячейки памяти, содержащие данные
(известные как «внешние» данные) или также могут использоваться для передачи прав порта
к другой задаче. Указатели вне строки данных особенно полезны, когда сообщение
должен передавать большие объемы данных. Простое сообщение потребует копирования и
упаковка данных в сообщение; внелинейная передача данных требует только
указатель, указывающий на ячейку памяти, в которой хранятся данные.
Функция mach msg() является стандартным API как для отправки, так и для
получение сообщений. Значение одного из параметров функции — либо
MACH SEND MSG или MACH RCV MSG — указывает, является ли это операцией отправки или получения.
Теперь мы проиллюстрируем, как он используется, когда клиентская задача отправляет простое сообщение
серверная задача. Предположим, что есть два порта — клиентский и серверный.
с задачами клиента и сервера соответственно. Код на рисунке 3.18 показывает
клиентская задача создает заголовок и отправляет сообщение на сервер, как
а также задача сервера, получающая сообщение, отправленное от клиента.
Вызов функции mach msg() вызывается пользовательскими программами для выполнения
передача сообщений. mach msg() затем вызывает функцию mach msg capture(),
это системный вызов ядра Mach. Внутри ядра выполните команду msg catch().
затем вызывает функцию mach msg overwrite capture(), которая затем обрабатывает
фактическая передача сообщения.

#include<mach/mach.h>

структура сообщения {
mac msg header t header;
целочисленные данные;
};

максимальный порт t клиента;
максимальный порт t сервера;

/* Код клиента */

сообщение структуры сообщения;

// создаем заголовок
message.header.msgh размер = sizeof(сообщение);
message.header.msgh удаленный порт = сервер;
message.header.msgh локальный порт = клиент;

// отправляем сообщение
mach msg(&message.header, // заголовок сообщения
MACH SEND MSG, // отправка сообщения
sizeof(message), // размер отправленного сообщения
0, // максимальный размер полученного сообщения - ненужно
MACH PORT NULL, // имя порта приема – необязательно
MACH MSG TIMEOUT NONE, // тайм-аутов нет
MACH PORT NULL // нет порта уведомления
);
/* Код сервера */

сообщение структуры сообщения;

// получаем сообщение
mach msg(&message.header, // заголовок сообщения
MACH RCV MSG, // отправка сообщения
0, // размер отправленного сообщения
sizeof(message), // максимальный размер полученного сообщения
сервер, // имя порта приема
MACH MSG TIMEOUT NONE, // тайм-аутов нет
MACH PORT NULL // нет порта уведомления
);

Рисунок 3.18 Пример программы, иллюстрирующей передачу сообщений на Маха.

Сами операции отправки и получения являются гибкими. Например, когда
сообщение отправлено в порт, его очередь может быть заполнена. Если очередь не заполнена,
сообщение копируется в очередь, и задача отправки продолжается. Если
очередь порта заполнена, у отправителя есть несколько вариантов (указанных через параметры
для обработки msg():
1. Ждать бесконечно, пока в очереди не освободится место.
2. Подождите не более n миллисекунд.
3. Не ждите вообще, а сразу возвращайтесь.
4. Временно кэшируйте сообщение. Здесь передается сообщение оператору
систему, даже несмотря на то, что очередь, в которую отправляется это сообщение,
отправлено полно. Когда сообщение можно поместить в очередь, появится уведомление.
сообщение отправляется обратно отправителю. Только одно сообщение в полной очереди может
быть ожидающими в любое время для данного потока отправки.
Последний вариант предназначен для серверных задач. После завершения запроса сервер
задаче может потребоваться отправить одноразовый ответ задаче, запросившей услугу,
но он также должен продолжать обработку других запросов на обслуживание, даже если порт ответа для
клиент переполнен.
Основная проблема систем сообщений обычно заключалась в низкой производительности.
мания, вызванная копированием сообщений из порта отправителя в порт получателя.
порт. Система сообщений Маха пытается избежать операций копирования, используя
методы управления виртуальной памятью (глава 10). По сути, карты Маха
адресное пространство, содержащее сообщение отправителя, в адрес получателя
космос. Таким образом, само сообщение никогда не копируется, поскольку отправитель
и приемник имеют доступ к одной и той же памяти. Эта техника управления сообщениями
обеспечивает значительный прирост производительности, но работает только для внутрисистемных сообщений.

3.7.3 Окна

Операционная система Windows является примером современного дизайна, в котором используется
модульность для увеличения функциональности и сокращения времени, необходимого для реализации.
сообщите о новых функциях. Windows обеспечивает поддержку нескольких операционных сред.
среды или подсистемы. Прикладные программы взаимодействуют с этими суб-
системы через механизм передачи сообщений. Таким образом, прикладные программы могут быть
считал клиенты подсистемы серверной.
Средство передачи сообщений в Windows называется расширенным локальным интерфейсом.
возможность временного вызова (ALPC). Он используется для связи между двумя процессами.
на той же машине. Это похоже на стандартный удаленный вызов процедур (RPC).
механизм, который широко используется, но оптимизирован и специфичен для Windows.
(Удаленные вызовы процедур подробно описаны в разделе 3.8.2.) Как и Mach, Win-
dows использует объект порта для установления и поддержания соединения между двумя
процессы. Windows использует два типа портов: порты подключения и коммуникационные порты.
катионные порты.
Серверные процессы публикуют объекты портов подключения, которые видны всем про-
уступки. Когда клиент хочет получить услуги от подсистемы, он открывает дескриптор
объект порта подключения сервера и отправляет запрос на подключение к этому порту.
Затем сервер создает канал и возвращает дескриптор клиенту. Чан-
nel состоит из пары частных портов связи: один для клиент-сервера.
сообщения, другой — для сообщений сервер-клиент. Кроме того, общение
каналы поддерживают механизм обратного вызова, который позволяет клиенту и серверу
принимать запросы, когда они обычно ожидают ответа.

При создании канала ALPC используется один из трех методов передачи сообщений.
выбран:
1. Для небольших сообщений (до 256 байт) используется очередь сообщений порта.
в качестве промежуточного хранилища, и сообщения копируются из одного процесса в
другой.
2. Сообщения большего размера необходимо передавать через объект раздела, который представляет собой
область общей памяти, связанная с каналом.
3. Когда объем данных слишком велик, чтобы поместиться в объект раздела, API
доступный, который позволяет серверным процессам читать и записывать непосредственно в
адресное пространство клиента.
Клиент должен решить при настройке канала, понадобится ли ему
отправить большое сообщение. Если клиент определяет, что он действительно хочет отправить
большие сообщения, он запрашивает создание объекта раздела. Аналогично, если сервер
решает, что ответы будут большими, создает объект раздела. Чтобы раздел
объект можно использовать, отправляется небольшое сообщение, содержащее указатель и размер
информация об объекте раздела. Этот метод сложнее, чем
первый метод, указанный выше, но он позволяет избежать копирования данных. Структура продвинутых
вызовы локальных процедур в Windows показаны на рисунке 3.19.
Важно отметить, что функция ALPC в Windows не является частью
Windows API и, следовательно, не виден программисту приложения. Скорее,
приложения, использующие Windows API, вызывают стандартные удаленные вызовы процедур.
Когда RPC вызывается для процесса в той же системе, RPC
обрабатывается косвенно через вызов процедуры ALPC. Кроме того, многие ядра
службы используют ALPC для взаимодействия с клиентскими процессами.

3.7.4 Трубы

Канал действует как канал, позволяющий взаимодействовать двум процессам. Трубы были
один из первых механизмов IPC в ранних системах UNIX. Обычно они про-
показать один из более простых способов взаимодействия процессов друг с другом,
хотя они также имеют некоторые ограничения. При внедрении трубы четыре проблемы
должны быть рассмотрены:

1. Разрешает ли канал двустороннюю связь или связь
однонаправленный?
2. Если разрешена двусторонняя связь, является ли она полудуплексной (данные могут передаваться
одновременно только в одну сторону) или полнодуплексный (данные могут передаваться в обоих направлениях
в то же время)?
3. Должны ли существовать отношения (например, родитель-ребенок) между сообществом?
процессы питания?
4. Могут ли трубы обмениваться данными по сети или же
процессы находятся на одной машине?
В следующих разделах мы рассмотрим два распространенных типа труб, используемых в обоих случаях.
Системы UNIX и Windows: обычные каналы и именованные каналы.

3.7.4.1 Обычные трубы

Обычные каналы позволяют двум процессам взаимодействовать в стандартном продюсере:
потребительская мода: производитель записывает на один конец канала (конец записи)
и потребитель читает с другого конца (конец чтения). В результате обычный
трубы являются однонаправленными, что обеспечивает только одностороннюю связь. Если двустороннее
необходима связь, необходимо использовать две трубы, при этом каждая труба передает
данные в другом направлении. Далее мы проиллюстрируем построение обычных труб.
как в системах UNIX, так и в Windows. В обоих примерах программы один процесс
записывает сообщение Приветствие в канал, в то время как другой процесс читает это
сообщение из трубы.
В системах UNIX обычные каналы создаются с помощью функции

труба (интервал FD[])

Эта функция создает канал, доступ к которому осуществляется через описание файла int fd[].
tors: fd[0] — конец канала для чтения, а fd[1] — конец для записи. UNIX рассматривает
Pipe как особый тип файла. Таким образом, доступ к каналам можно получить с помощью обычного read().
и системные вызовы write().
К обычному каналу нельзя получить доступ снаружи процесса, создавшего
это. Обычно родительский процесс создает канал и использует его для связи с
дочерний процесс, который он создает с помощью fork(). Напомним из раздела 3.3.1, что ребенок
процесс наследует открытые файлы от своего родителя. Поскольку труба представляет собой особый тип
файл, дочерний процесс наследует канал от родительского процесса. Рисунок 3.20 иллюстрирует
отношение файловых дескрипторов в массиве fd к родительскому и дочернему элементу
процессы. Как видно из этого, любая запись родительского элемента в его конец записи
канал — fd[1] — может быть прочитан дочерним элементом со стороны чтения — fd[0] —
трубка.

#include <sys/types.h>
#include <stdio.h>
#include <строка.h>
#include <unistd.h>

#define РАЗМЕР БУФЕРА 25
#define КОНЕЦ ЧТЕНИЯ 0
#define ЗАПИСАТЬ КОНЕЦ 1

int main (недействительный)
{
char write msg[РАЗМЕР БУФЕРА] = "Привет";
char прочитать сообщение [РАЗМЕР БУФЕРА];
интервал ФД[2];
пид т пид;

/* Программа продолжается на рисунке 3.22 */

Рисунок 3.21 Обычный канал в UNIX.

В программе UNIX, показанной на рисунке 3.21, родительский процесс создает
Pipe, а затем отправляет вызов fork(), создающий дочерний процесс. Что происходит
после вызова fork() зависит от того, как данные должны проходить через канал.
В этом случае родительский элемент записывает в канал, а дочерний элемент читает из него. Это
важно отметить, что изначально и родительский процесс, и дочерний процесс
закрыть неиспользуемые концы трубы. Хотя программа, показанная на рис.
3.21 не требует этого действия, это важный шаг, гарантирующий, что процесс
чтение из канала может обнаружить конец файла (read() возвращает 0), когда записывающий
закрыл свой конец трубы.
Обычные каналы в системах Windows называются анонимными каналами.
они ведут себя аналогично своим аналогам в UNIX: они однонаправлены и
использовать родительско-дочерние отношения между коммуникативными процессами. В
Кроме того, чтение и запись в канал могут выполняться обычным способом.
ни одной функции ReadFile() и WriteFile(). Windows API для создания
Pipes — это функция CreatePipe(), которой передаются четыре параметра.
параметры предоставляют отдельные дескрипторы для (1) чтения и (2) записи в канал,
а также (3) экземпляр структуры STARTUPINFO, который используется для указания
что дочерний процесс должен наследовать дескрипторы канала. Кроме того, (4)
Можно указать размер канала (в байтах).
На рис. 3.23 показан родительский процесс, создающий анонимный канал для
общение со своим ребенком. В отличие от систем UNIX, в которых детский программный
cess автоматически наследует канал, созданный его родителем, Windows требует
программисту, чтобы указать, какие атрибуты унаследует дочерний процесс. Это
достигается путем первой инициализации структуры АТРИБУТЫ БЕЗОПАСНОСТИ, позволяющей
дескрипторы для наследования, а затем перенаправление дескрипторов дочернего процесса для
стандартный ввод или стандартный вывод в дескриптор чтения или записи канала. С
ребенок будет читать из канала, родитель должен перенаправить поток ребенка
стандартный ввод в дескриптор чтения канала. Кроме того, поскольку трубы наполовину
дуплекса, необходимо запретить ребенку наследовать конец записи
трубка. Программа создания дочернего процесса аналогична программе на рис.
3.10, за исключением того, что пятый параметр имеет значение TRUE, что указывает на то, что дочерний элемент
Процесс должен наследовать назначенные дескрипторы от своего родителя. Прежде чем писать в
канал, родительский элемент сначала закрывает неиспользуемый конец канала для чтения. Дочерний процесс
который читает из канала, показан на рисунке 3.25. Прежде чем читать из трубы,
эта программа получает дескриптор чтения канала, вызывая GetStdHandle().

/* создаем канал */
если (труба(fd) == -1) {
fprintf(stderr,"Ошибка канала");
возврат 1;
}
/* создаем дочерний процесс */
пид = вилка();
if (pid < 0) { /* произошла ошибка */
fprintf(stderr, «Ошибка вилки»);
возврат 1;
}

if (pid > 0) { /* родительский процесс */
/* закрываем неиспользуемый конец канала */
закрыть(fd[ЧИТАТЬ КОНЕЦ]);

/* запись в канал */
write(fd[WRITE END], write msg, strlen(write msg)+1);

/* закрываем конец канала записи */
закрыть (fd [КОНЕЦ ЗАПИСИ]);
}
else { /* дочерний процесс */
/* закрываем неиспользуемый конец канала */
закрыть (fd [КОНЕЦ ЗАПИСИ]);
/* чтение из канала */
read(fd[READ END], прочитать сообщение, РАЗМЕР БУФЕРА);
printf("прочитать %s", прочитать сообщение);
/* закрываем конец канала чтения */
закрыть(fd[ЧИТАТЬ КОНЕЦ]);
}
вернуть 0;
}

Рисунок 3.22 Рисунок 3.21, продолжение

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define РАЗМЕР БУФЕРА 25

интервал основной (VOID)
{
РУЧКА ReadHandle, WriteHandle;
СТАРТАПИНФО си;
ИНФОРМАЦИЯ О ПРОЦЕССЕ pi;
char message[РАЗМЕР БУФЕРА] = "Привет";
DWORD записан;

/* Программа продолжается на рисунке 3.24 */

Рисунок 3.23. Анонимный канал Windows — родительский процесс.

Обратите внимание, что обычные каналы требуют наличия отношений «родитель-потомок» между
взаимодействующие процессы в системах UNIX и Windows. Это означает
что эти каналы можно использовать только для связи между процессами на сервере.
та же машина.

3.7.4.2 Именованные каналы

Обычные каналы предоставляют простой механизм, позволяющий выполнять пару процессов.
общаться. Однако обычные трубы существуют только пока идут процессы.
общаясь друг с другом. В системах UNIX и Windows один раз
процессы закончили общение и завершились, обычное дело
труба перестает существовать.
Именованные каналы предоставляют гораздо более мощный инструмент связи. Ком-
коммуникация может быть двунаправленной, и отношения родитель-потомок не требуются.
Как только именованный канал установлен, несколько процессов могут использовать его для связи.
катион. Фактически, в типичном сценарии именованный канал имеет несколько авторов. Адди-
теоретически именованные каналы продолжают существовать после завершения взаимодействующих процессов.
законченный. Системы UNIX и Windows поддерживают именованные каналы, хотя
детали реализации сильно различаются. Далее мы исследуем именованные каналы в каждом
этих систем.
Именованные каналы в системах UNIX называются FIFO. Однажды созданные, они
выглядят как обычные файлы в файловой системе. FIFO создается с помощью mkfifo().
системный вызов и управляется с помощью обычных open(), read(), write(),
и системные вызовы close(). Он будет продолжать существовать до тех пор, пока не будет явно удален.
из файловой системы. Хотя FIFO допускают двунаправленную связь, только
разрешена полудуплексная передача. Если данные должны передаваться в обоих направлениях,
обычно используются два FIFO. Кроме того, процессы связи должны
находиться на одной машине. Если требуется межмашинная связь,
ets (раздел 3.8.1).

/* устанавливаем атрибуты безопасности, позволяющие наследовать каналы */
АТРИБУТЫ БЕЗОПАСНОСТИ sa = {sizeof(АТРИБУТЫ БЕЗОПАСНОСТИ), NULL, TRUE};
/* выделяем память */
ZeroMemory(&pi, sizeof(pi));
/* создаем канал */

if (!CreatePipe(&ReadHandle, &WriteHandle, &sa, 0)) {
fprintf(stderr, «Ошибка создания канала»);
возврат 1;
}

/* устанавливаем структуру START INFO для дочернего процесса */
GetStartupInfo(&si);
si.hStdOutput = GetStdHandle(STD OUTPUT HANDLE);

/* перенаправляем стандартный ввод на конец канала чтения */
si.hStdInput = ReadHandle;
si.dwFlags = НАЧАЛО USESTDHANDLES;

/* не позволяем дочернему элементу наследовать конец канала записи */
SetHandleInformation(WriteHandle, HANDLE FLAG INHERIT, 0);

/* создаем дочерний процесс */
CreateProcess(NULL, "child.exe", NULL, NULL,
TRUE, /* наследовать дескрипторы */
0, NULL, NULL, &si, &pi);

/* закрываем неиспользуемый конец канала */
CloseHandle(ReadHandle);

/* родитель записывает в канал */
if (!WriteFile(WriteHandle, сообщение, РАЗМЕР БУФЕРА,&записано,NULL))
fprintf(stderr, "Ошибка записи в канал.");

/* закрываем конец канала записи */
CloseHandle(WriteHandle);

/* ждем, пока дочерний элемент выйдет */
WaitForSingleObject(pi.hProcess, БЕСКОНЕЧНЫЙ);
CloseHandle(pi.hProcess);
CloseHandle(pi.hThread);
вернуть 0;
}

Рисунок 3.24 Рисунок 3.23, продолжение.


#include <stdio.h>
#include <windows.h>

#define РАЗМЕР БУФЕРА 25

интервал основной (VOID)
{
РУЧКА Ручка чтения;
Буфер CHAR [РАЗМЕР БУФЕРА];
DWORD прочитано;

/* получаем дескриптор чтения канала */
ReadHandle = GetStdHandle (STD INPUT HANDLE);

/* ребенок читает из трубы */
if (ReadFile(ReadHandle, буфер, РАЗМЕР БУФЕРА, &read, NULL))
printf("ребенок прочитал %s",buffer);
еще
fprintf(stderr, «Ошибка чтения из канала»);
вернуть 0;
}

Рисунок 3.25 Анонимные каналы Windows — дочерний процесс.

Именованные каналы в системах Windows предоставляют более богатый механизм связи.
анизм, чем их аналоги из UNIX. Разрешена полнодуплексная связь,
и процессы связи могут находиться как на одном, так и на разных
машины. Кроме того, по каналу могут передаваться только байтовые данные.
UNIX FIFO, тогда как системы Windows допускают либо байтовую, либо ориентированную на сообщения
данные. Именованные каналы создаются с помощью функции CreateNamedPipe(), а
клиент может подключиться к именованному каналу с помощью ConnectNamedPipe(). Сообщество
Обращение к именованному каналу можно выполнить с помощью ReadFile() и
Функции WriteFile().

3.8 Связь в клиент-серверных системах

В разделе 3.4 мы описали, как процессы могут взаимодействовать с использованием общих
память и передача сообщений. Эти методы могут быть использованы для коммуникации.
в системах клиент-сервер (раздел 1.10.3). В этом разделе мы исследуем
две другие стратегии взаимодействия в системах клиент-сервер: сокеты и
удаленные вызовы процедур (RPC). Как мы увидим в нашем обзоре RPC, не
они полезны только для клиент-серверных вычислений, но Android также использует удаленные
процедуры как форма IPC между процессами, работающими в одной системе.

3.8.1 Розетки

Сокет определяется как конечная точка для связи. Пара процессов со-
при общении по сети используется пара сокетов — по одному для каждого процесса.
Сокет идентифицируется IP-адресом, объединенным с номером порта. В
Как правило, сокеты используют архитектуру клиент-сервер. Сервер ожидает входящего
клиентские запросы, прослушивая указанный порт. Как только запрос получен,
сервер принимает соединение из клиентского сокета для завершения соединения.
Серверы, реализующие определенные службы (такие как SSH, FTP и HTTP), прослушивают
общеизвестные порты (сервер SSH слушает порт 22; сервер FTP слушает
порт 21; и веб-сервер или HTTP-сервер прослушивает порт 80). Все порты ниже 1024
считаются хорошо известными и используются для реализации стандартных сервисов.
Когда клиентский процесс инициирует запрос на соединение, ему назначается
порт на своем главном компьютере. Этот порт имеет произвольное число больше, чем
1024. Например, если клиент на хосте X с IP-адресом 146.86.5.20 желает
установить соединение с веб-сервером (который прослушивает порт 80) по адресу
адрес 161.25.19.8, хосту X может быть назначен порт 1625. Соединение будет
состоят из пары сокетов: (146.86.5.20:1625) на хосте X и (161.25.19.8:80)
на веб-сервере. Эта ситуация проиллюстрирована на рисунке 3.26. Пакеты
перемещения между хостами передаются соответствующему процессу на основе
номер порта назначения.

Все соединения должны быть уникальными. Поэтому, если другой процесс также на хосте
X хотел бы установить другое соединение с тем же веб-сервером, это было бы
назначен номер порта больше 1024 и не равен 1625. Это обеспечивает
что все соединения состоят из уникальной пары сокетов.
Хотя в большинстве примеров программ в этом тексте используется язык C, мы проиллюстрируем
сокетов с использованием Java, поскольку он обеспечивает гораздо более простой интерфейс для сокетов и имеет
богатая библиотека сетевых утилит. Те, кто интересуется программированием сокетов
на C или C++ следует обратиться к библиографическим примечаниям в конце главы.
Java предоставляет три различных типа сокетов. Ориентированный на соединение (TCP)
сокеты реализуются с помощью класса Socket. Сокеты без установления соединения (UDP)
используйте класс DatagramSocket. Наконец, класс MulticastSocket является подклассом
класс класса DatagramSocket. Многоадресный сокет позволяет отправлять данные
несколько получателей.
В нашем примере описывается сервер данных, использующий TCP с установлением соединения.
Розетки. Операция позволяет клиентам запрашивать текущую дату и время у
сервер. Сервер слушает порт 6013, хотя порт может быть любой.
произвольное неиспользуемое число больше 1024. При получении соединения
сервер возвращает клиенту дату и время.
Сервер данных показан на рисунке 3.27. Сервер создает ServerSocket
это указывает, что он будет прослушивать порт 6013. Затем сервер начинает прослушивать
в порт с помощью метода Accept(). Сервер блокирует метод Accept().
метод ожидает, пока клиент запросит соединение. Когда запрос на соединение
получено, Accept() возвращает сокет, который сервер может использовать для связи
с клиентом.
Подробности того, как сервер взаимодействует с сокетом, следующие.
Сервер сначала устанавливает объект PrintWriter, который он будет использовать для связи.
общаться с клиентом. Объект PrintWriter позволяет серверу писать в
сокет, используя для вывода обычные методы print() и println().
Серверный процесс отправляет дату клиенту, вызывая метод println(). Один раз
он записал дату в сокет, сервер закрывает сокет для клиента и
возобновляет прослушивание дополнительных запросов.

импортировать java.net.*;
импортировать java.io.*;

общедоступный класс DateServer
{
public static void main(String[] args) {
пытаться {
ServerSocket sock = новый ServerSocket(6013);

/* теперь прослушиваем соединения */
в то время как (истина) {
Клиент сокета = sock.accept();

PrintWriter pout = новый
PrintWriter(client.getOutputStream(), true);
/* записываем дату в сокет */
pout.println(новый java.util.Date().toString());

/* закрываем сокет и возобновляем работу */
/* прослушиваем соединения */
клиент.закрыть();
}
}
поймать (IOException ioe) {
System.err.println(ioe);
}
}
}

Рисунок 3.27 Сервер данных.

Клиент взаимодействует с сервером, создавая сокет и подключаясь
к порту, который прослушивает сервер. Мы реализуем такой клиент в
Java-программа показана на рисунке 3.28. Клиент создает сокет и запрашивает
соединение с сервером по IP-адресу 127.0.0.1 по порту 6013. Как только
соединение установлено, клиент может читать из сокета, используя обычный поток
Операторы ввода-вывода. После получения даты с сервера клиент закрывается.
розетка и выходы. IP-адрес 127.0.0.1 — это специальный IP-адрес, известный как
обратная связь. Когда компьютер обращается к IP-адресу 127.0.0.1, он ссылается на себя.
Этот механизм позволяет клиенту и серверу на одном хосте взаимодействовать.
с использованием протокола TCP/IP. IP-адрес 127.0.0.1 можно заменить на
IP-адрес другого хоста, на котором работает сервер данных. Помимо IP-адреса,
в качестве имени хоста можно использовать фактическое имя хоста, например www.westminstercollege.edu.
хорошо.

импортировать java.net.*;
импортировать java.io.*;

публичный класс DateClient
{
public static void main(String[] args) {
пытаться {
/* устанавливаем соединение с сокетом сервера */
Socket sock = новый Socket("127.0.0.1",6013);
InputStream in = sock.getInputStream();
BufferedReader bin = новый
BufferedReader (новый InputStreamReader (в));
/* читаем дату из сокета */
Струнная линия;
while ((line = bin.readLine()) != null)
System.out.println(строка);
/* закрываем соединение с сокетом*/
носок.закрыть();
}
поймать (IOException ioe) {
System.err.println(ioe);
}
}
}

Рисунок 3.28 Клиент даты.

Коммуникация с использованием сокетов, хотя и распространена и эффективна, но
рассматривал низкоуровневую форму связи между распределенными процессами.
Одна из причин заключается в том, что сокеты позволяют передавать только неструктурированный поток байтов.
обмениваются между взаимодействующими потоками. Это ответственность
клиентское или серверное приложение для наложения структуры на данные. В следующем подразделе
разделе мы рассмотрим метод связи более высокого уровня: удаленную процедуру
вызовы (RPC).

3.8.2 Удаленные вызовы процедур

Одной из наиболее распространенных форм удаленного обслуживания является парадигма RPC, которая
был разработан как способ абстрагировать механизм вызова процедур для использования
между системами с сетевыми подключениями. Во многом он похож на
Механизм IPC описан в разделе 3.4 и обычно строится поверх такого
система. Однако здесь, поскольку мы имеем дело со средой, в которой
процессы выполняются в отдельных системах, мы должны использовать систему на основе сообщений
схема связи для предоставления удаленного обслуживания.

В отличие от сообщений IPC, сообщения, которыми обмениваются в RPC-сообщениях,
катионы хорошо структурированы и, таким образом, больше не являются просто пакетами данных. Каждый
Сообщение адресовано демону RPC, прослушивающему порт на удаленной системе.
tem, и каждый содержит идентификатор, определяющий функцию для выполнения и
параметры для передачи в эту функцию. Затем функция выполняется по запросу,
и любой вывод отправляется обратно запрашивающей стороне в отдельном сообщении.
Порт в этом контексте — это просто номер, включенный в начало сообщения.
пакет. Хотя система обычно имеет один сетевой адрес, она может иметь
множество портов внутри этого адреса, чтобы различать множество сетевых служб, которые он использует.
поддерживает. Если удаленному процессу требуется услуга, он отправляет сообщение
правильный порт. Например, если система желает разрешить другим системам быть
сможет составить список своих текущих пользователей, у него будет демон, поддерживающий такой RPC
подключен к порту, скажем, порту 3027. Любая удаленная система может получить необходимые
информацию (то есть список текущих пользователей), отправив сообщение RPC на порт
3027 на сервере. Данные будут получены в ответном сообщении.
Семантика RPC позволяет клиенту вызывать процедуру на удаленном компьютере.
хост, поскольку он будет вызывать процедуру локально. Система RPC скрывает детали
которые позволяют осуществлять связь, предоставляя заглушку на стороне клиента.
Обычно для каждой отдельной удаленной процедуры существует отдельная заглушка. Когда
клиент вызывает удаленную процедуру, система RPC вызывает соответствующую
заглушку, передав ей параметры, предоставленные удаленной процедуре. Эта заглушка
находит порт на сервере и маршалирует параметры. Заглушка тогда
передает сообщение на сервер, используя передачу сообщений. Похожая заглушка на
серверная сторона получает это сообщение и вызывает процедуру на сервере. Если
При необходимости возвращаемые значения передаются обратно клиенту с использованием того же метода.
В системах Windows код-заглушка компилируется на основе спецификации, написанной в
Язык определения интерфейса Microsoft (MIDL), который используется для определения
интерфейсы между клиентскими и серверными программами.
Маршалинг параметров решает проблему различий в данных.
представление на клиентских и серверных машинах. Рассмотрим представление-
32-битных целых чисел. Некоторые системы (известные как big-endian) хранят больше всего
сначала значащий байт, в то время как другие системы (известные как Little-Endian) сохраняют
младший байт первым. Ни один из этих порядков не является «лучшим» сам по себе; скорее, выбор
произвольный в рамках компьютерной архитектуры. Чтобы разрешить подобные разногласия, многие
Системы RPC определяют машинно-независимое представление данных. Один такой
представление известно как представление внешних данных (XDR). На клиенте
Со стороны маршалинг параметров включает в себя преобразование машинно-зависимых данных.
в XDR перед отправкой на сервер. На стороне сервера данные XDR
немаршализованный и преобразованный в машинно-зависимое представление для
сервер.
Другой важный вопрос касается семантики вызова. В то время как местные
вызовы процедур терпят неудачу только в крайних обстоятельствах, RPC могут выйти из строя или быть
дублируется и выполняется более одного раза в результате общей сети
ошибки. Одним из способов решения этой проблемы является обеспечение операционной системой
что сообщения обрабатываются ровно один раз, а не максимум один раз. Самый местный
вызовы процедур имеют функцию «ровно один раз», но их сложнее
осуществлять.
Во-первых, рассмотрим «не более одного раза». Эту семантику можно реализовать путем прикрепления
присвоение временной метки каждому сообщению. Сервер должен хранить историю всех
временные метки сообщений, которые он уже обработал, или достаточно большая история
чтобы гарантировать обнаружение повторяющихся сообщений. Входящие сообщения, имеющие
отметка времени, уже находящаяся в истории, игнорируется. Затем клиент может отправить
сообщение один или несколько раз и будьте уверены, что оно будет выполнено только один раз.
Для «ровно один раз» нам нужно устранить риск того, что сервер никогда не
получить запрос. Для этого сервер должен реализовать принцип «не более
один раз», описанный выше, но также должен подтвердить клиенту, что
вызов RPC был получен и выполнен. Эти сообщения ACK являются общими.
на протяжении всей сети. Клиент должен периодически повторно отправлять каждый вызов RPC до тех пор, пока
он получает ACK для этого вызова.
Еще один важный вопрос касается связи между сервером.
и клиент. При стандартных вызовах процедур имеет место некоторая форма привязки.
во время компоновки, загрузки или выполнения (глава 9), чтобы имя вызова процедуры
заменяется адресом памяти вызова процедуры. Схема RPC
требует аналогичной привязки клиента и порта сервера, но как клиент
знаете номера портов на сервере? Ни одна система не имеет полной информации.
о другом, потому что у них нет общей памяти.
Распространены два подхода. Во-первых, информация привязки может быть заранее
завершается в виде фиксированных адресов портов. Во время компиляции вызов RPC имеет
фиксированный номер порта, связанный с ним. После компиляции программы сервер
не может изменить номер порта запрошенной службы. Во-вторых, привязка может быть
осуществляется динамически с помощью механизма рандеву. Обычно операционная система
предоставляет демон рандеву (также называемый свахом) на фиксированном порту RPC.
Затем клиент отправляет сообщение, содержащее имя RPC, на место встречи.
демон запрашивает адрес порта RPC, который ему необходимо выполнить. Порт
возвращается номер, и вызовы RPC могут отправляться на этот порт до тех пор, пока процесс не
завершается (или сервер выходит из строя). Этот метод требует дополнительных затрат на
первоначальный запрос, но он более гибок, чем первый подход. На рисунке 3.29 показано
образец взаимодействия.
Схема RPC полезна при реализации распределенной файловой системы (гл.
тер 19). Такая система может быть реализована как набор демонов и клиентов RPC.
Сообщения адресуются порту распределенной файловой системы на сервере
какую файловую операцию должна выполнить. Сообщение содержит операцию с диском
быть выполнено. Дисковая операция может быть read(), write(), rename(),
delete() или status(), что соответствует обычным системным вызовам, связанным с файлами.
Возвратное сообщение содержит все данные, полученные в результате этого вызова, которые исполняются.
вырезается демоном DFS от имени клиента. Например, сообщение может
содержать просьбу передать клиенту целый файл или ограничиваться простым
заблокировать запрос. В последнем случае может потребоваться несколько запросов, если файл целиком
предстоит перенести.

3.8.2.1 Android RPC

Хотя RPC обычно связаны с вычислениями клиент-сервер
распределенную систему, их также можно использовать как форму IPC между процессами.
работает в той же системе. Операционная система Android имеет богатый набор
Механизмы IPC, содержащиеся в его связующей структуре, включая RPC, которые позволяют
один процесс запрашивает услуги у другого процесса.
Android определяет компонент приложения как базовый строительный блок, который
предоставляет полезность приложению Android, и приложение может сочетать в себе несколько
компоненты приложения для обеспечения функциональности приложения. Одно из таких приложений-
компонент — это служба, которая не имеет пользовательского интерфейса, но вместо этого работает в
фон во время выполнения длительных операций или выполнения работы
для удаленных процессов. Примеры услуг включают воспроизведение музыки на заднем плане.
заземление и получение данных через сетевое соединение от имени другого
процесс, тем самым предотвращая блокировку другого процесса, поскольку данные
загружается. Когда клиентское приложение вызывает методbindService()
службы, эта служба «привязана» и доступна для предоставления клиент-серверной
связь с использованием передачи сообщений или RPC.
Связанная служба должна расширять класс Android Service и должна реализовывать
Вспомним метод onBind(), который вызывается, когда клиент вызывает метод BindSer-
порок(). В случае передачи сообщения метод onBind() возвращает Mes-
служба sanger, которая используется для отправки сообщений от клиента к
услуга. Служба обмена сообщениями работает только в одну сторону; если служба должна отправить ответ
обратно клиенту, клиент также должен предоставить услугу обмена сообщениями, которая
содержится в поле AnswerTo объекта Message, отправленного в службу.
служба может затем отправлять сообщения обратно клиенту.
Чтобы предоставить RPC, метод onBind() должен возвращать представление интерфейса.
отправка методов удаленного объекта, которые клиенты используют для взаимодействия с
услуга. Этот интерфейс написан на обычном синтаксисе Java и использует Android.
Язык определения интерфейса — AIDL — для создания файлов-заглушек, которые служат
клиентский интерфейс для удаленных сервисов.
Здесь мы кратко описываем процесс, необходимый для предоставления универсального пульта дистанционного управления.
сервис с именем RemoteMethod() с использованием AIDL и службы связывания. Меж-
Лицо для удаленной службы выглядит следующим образом:

/* RemoteService.aidl */
интерфейс RemoteService
{
логический RemoteMethod(int x, double y);
}

Этот файл записывается как RemoteService.aidl. Комплект разработчика Android
будет использовать его для создания интерфейса .java из файла .aidl, а также заглушки
который служит интерфейсом RPC для этой службы. Сервер должен реализовать
интерфейс, созданный файлом .aidl, и реализация этого интерфейса
будет вызываться, когда клиент вызывает RemoteMethod().
Когда клиент вызывает метод bindService(), метод onBind() вызывается
серверу и возвращает клиенту заглушку объекта RemoteService.
Затем клиент может вызвать удаленный метод следующим образом:

служба удаленного обслуживания;
. . .
service.remoteMethod(3, 0.14);

Внутри платформа связывания Android обрабатывает маршалинг параметров.
передача маршалированных параметров между процессами и вызов необходимых
необходимая реализация сервиса, а также отправка возвращаемых значений обратно
к клиентскому процессу.

3.9 Резюме

• Процесс – это выполняемая программа, а статус текущей деятельности
процесс представлен программным счетчиком, а также другими регистрами.
• Структура процесса в памяти представлена четырьмя различными разделами:
(1) текст, (2) данные, (3) куча и (4) стек.
• По мере выполнения процесса он меняет состояние. Существует четыре основных состояния
процесс: (1) готов, (2) работает, (3) ожидает и (4) завершен.
• Блок управления процессом (PCB) – это структура данных ядра, которая представляет собой
процесс в операционной системе.
• Роль планировщика процессов заключается в выборе доступного процесса для запуска.
процессор.
• Операционная система выполняет переключение контекста при переключении с
запуск одного процесса для запуска другого.

• Системные вызовы fork() и CreateProcess() используются для создания про-
прекращается в системах UNIX и Windows соответственно.
• Когда для связи между процессами используется общая память, два
(или более) процессов используют одну и ту же область памяти. POSIX предоставляет
API для общей памяти.
• Два процесса могут взаимодействовать путем обмена сообщениями с одним
другой с использованием передачи сообщений. Операционная система Mach использует сообщение
проходя в качестве основной формы межпроцессного взаимодействия. Окна
также обеспечивает форму передачи сообщений.
• Канал обеспечивает канал для взаимодействия двух процессов. Есть
две формы трубок: обычные и именные. Обычные трубы предназначены для
связь между процессами, имеющими родительско-дочерние отношения.
Именованные каналы являются более общими и позволяют нескольким процессам взаимодействовать друг с другом.
кат.
• Системы UNIX предоставляют обычные каналы посредством системного вызова Pipe().
Обычные каналы имеют конец чтения и конец записи. Родительский процесс может, например
Например, отправьте данные в канал, используя его конец записи, а дочерний процесс
может прочитать его с конца чтения. Именованные каналы в UNIX называются FIFO.
• Системы Windows также предоставляют две формы каналов — анонимный и
именованные трубы. Анонимные каналы аналогичны обычным каналам UNIX. Они
являются однонаправленными и используют отношения родитель-потомок между
коммуникативные процессы. Именованные каналы предлагают более богатую форму межпроцессного взаимодействия.
связь, чем аналог UNIX, FIFO.
• Двумя распространенными формами связи клиент-сервер являются сокеты и
удаленные вызовы процедур (RPC). Сокеты позволяют двум процессам на разных
машины для связи по сети. RPC абстрагируют концепцию
функция (процедура) вызывается таким образом, что функцию можно вызвать
другой процесс, который может находиться на отдельном компьютере.
• Операционная система Android использует RPC как форму межпроцессного взаимодействия.
коммуникация с использованием связующей структуры.

Практические упражнения

3.1 Используя программу, показанную на рисунке 3.30, объясните, какой результат будет
быть на ЛИНИИ А.
3.2 Включая исходный родительский процесс, сколько процессов создается
программа, показанная на рисунке 3.31?
3.3 Исходные версии мобильной операционной системы Apple i OS не содержали
средства параллельной обработки. Обсудите три основных осложнения, которые
параллельная обработка расширяет операционную систему.
3.4 Некоторые компьютерные системы предоставляют несколько наборов регистров. Опишите, что
происходит, когда происходит переключение контекста, если новый контекст уже
загружен в один из наборов регистров. Что произойдет, если новый контекст
находится в памяти, а не в наборе регистров, и все наборы регистров находятся в
использовать?

#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

целое значение = 5;

интервал основной()
{
пид_т пид;

пид = вилка();

if (pid == 0) { /* дочерний процесс */
значение += 15;
вернуть 0;
}
else if (pid > 0) { /* родительский процесс */
подождать (NULL);
printf("РОДИТЕЛЬСКИЙ: значение = %d",значение); /* СТРОКА А */
вернуть 0;
}
}

Рисунок 3.30. Какой выход будет на линии А?

3.5 Когда процесс создает новый процесс с помощью операции fork(), которая
из следующих состояний совместно используются родительским процессом и дочерним процессом
процесс?
а. Куча
б. Куча
в. Сегменты общей памяти
3.6. Рассмотрим семантику «ровно один раз» в отношении механизма RPC.
Правильно ли выполняется алгоритм реализации этой семантики?
даже если сообщение ACK, отправленное обратно клиенту, потеряно из-за сетевой ошибки.
проблема с работой? Опишите последовательность сообщений и обсудите,
«ровно один раз» сохранилось до сих пор.
3.7 Предположим, что распределенная система подвержена сбою сервера. Что
потребуются механизмы, гарантирующие семантическое «ровно один раз».
для выполнения RPC?

#include <stdio.h>
#include <unistd.h>

интервал основной()
{
/* создаем дочерний процесс */
вилка();

/* создаем другой дочерний процесс */
вилка();

/* и создаем еще один */
вилка();

вернуть 0;
}

Рисунок 3.31 Сколько процессов создано?


Дальнейшее чтение

Создание процессов, управление ими и IPC в системах UNIX и Windows,
соответственно, обсуждаются в [Роббинс и Роббинс (2003)] и [Русинович
и другие. (2017)]. [Love (2010)] посвящена поддержке процессов в Linux.
ядро, а [Hart (2005)] подробно описывает программирование систем Windows.
Описание многопроцессной модели, используемой в Google Chrome, можно найти по адресу
http://blog.chromium.org/2008/09/multi-process-architecture.html.
Передача сообщений для многоядерных систем обсуждается в [Holland and Seltzer
(2011)]. [Левин (2013)] описывает передачу сообщений в системе Маха, в частности
в основном в отношении Mac OS и i OS.
[Гарольд (2005)] освещает программирование сокетов на Java. Подробности
на Android RPC можно найти по адресу https://developer.android.com/guide/compo.
nents/aidl.html. [Hart (2005)] и [Robbins and Robbins (2003)] покрывают трубы в
Системы Windows и UNIX соответственно.
Рекомендации по разработке для Android можно найти по адресу https://developer.and.
roid.com/guide/.

Библиография

[Гарольд (2005)] Э. Р. Гарольд, Сетевое программирование на Java, третье издание, O'Reilly
и партнеры (2005).
[Харт (2005)] Дж. М. Харт, Системное программирование для Windows, третье издание, Addison-
Уэсли (2005).
[Холланд и Зельцер (2011)] Д. Холланд и М. Зельцер, «Многоядерные операционные системы: посмотрите
ing Forward from 1991, э-э, 2011», Материалы 13-й конференции USENIX по горячим
темы операционных систем (2011 г.), страницы 33–33.
[Левин (2013)] Дж. Левин, Mac OS X и iOS Internals to the Apple’s Core, Wiley
(2013).
[Любовь (2010)] Р. Лав, Разработка ядра Linux, третье издание, Developer’s
Библиотека (2010).
[Роббинс и Роббинс (2003)] К. Роббинс и С. Роббинс, Unix Systems Pro-
граммирование: коммуникация, параллелизм и потоки, второе издание, Prentice
Холл (2003).
[Русинович и др. (2017)] М. Руссинович, Д. А. Соломон, А. Ионеску, Win-
Внутреннее устройство dows – Часть 1, седьмое издание, Microsoft Press (2017).
