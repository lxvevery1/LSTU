В прошлый раз рассмотрели о доставке письма

В обычном режиме, когда не тнутренней цепочки маршрутизации почты

Почему сервер исходящей почты может отклонить письмо?
Не проходит по политикам безопасности содержимое письма.
Размер, кол-во адресатов (много)
Если нет адресатов, если нет места, то оно уйдет, но в ответ вы получите новое письмо о недоставке
Открытый relay - любой может отправить письмо через другой почтовый домен - обычно запрещено.
Либо в анонимном режиме выполнить relay, либо само письмо.
Севрер скорее всего заберет письмо.
Письмо будет в прцоессе доставки либо отклонено.

# SMTP

По SMTP получатель не проверяется


Какие протоколы используются в процессе работы эл. почты.

UTU - unix-to-unix

SMTP или SMTPS - simple mail transport protocol
smtp default port: 25

Клиент подключается, выдает команду, сервер выполняет и выдает код результата выполнения команды

Переход от SMTP к SMTPS -> уже прочитать нельзя
Начинается работа с команды Hello.
И указывается DNS-имя клиента

Клиент может указать любое DNS-имя.
Так как SMTP используется в двух местах:
между к-с и с-с
в к-с используется аутентификация
между с-с используется в анонимном режиме

За счет проверки днс имени проверить его подлинность
Почтовый сервер видит в какого ip поступило подключение

HELO - команда в SMTP. В расширенной версии приветственная команда - EHLO. Можно проверить

pass - передача логина и пароля. Возможен вариант анонимной работы
return 220 -> ok!

...

Клиент управляет всей работой протокола, а сервер активности не проявляет, только выполняет команды.


# POP3

port: 110
Есть версия POP3S - 465 порт

POP3 требует обязательной аутентификации.
Почтовые агенты на POP3 работают так:
проверяеют входящую потчу, соединение с сервером, прохождение аутентификации, отправка писем.
Получил? Да. Сервер удаляет письмо после подтверждения.

Протокол синхронный.
В 1997 году было ограничение на 8мб

Письма забирались, потому что дисковое пространство было слишком дорогим.
Со временем использования подхода

Когда человек работает и получил письмо на работе, то из дома уже посмотреть на письмо не получится

.
Не удалять письмо на сервере? Не отправлять письмо о получении письма


# IMAP

IMAP4 - с установкой соединения.
std port: 143

Письма хранятся на сервере всегда
Письма при работе данного протокола не удаляются с сервера.
Процесс получения почты. Информация о наличии писем клиенту.
Когда открываем письмо, то оно кэшируется, но не удаляется на сервере.

В POP3 таого не было:
при большом объеме писем их надо каталогизировать - распределить по разным папкам
В POP3 было, но на стороне клиента. На сервере это все было в куче
В IMAP эта работа выполяется на стороне сервера - перемещает письма между папками.
Это стало когда дисковое пространство стало дешевле

IMAPS работает аналогично


# Электронное письмо
Текстовое сообщение, состоящшее из двух частей - залоговок и (пустая строка и) тело письма

залоговок письма сожержит поля письма - имя + значения
Какие поля в разделе заголовка присутствуют?

1. Тема
2. To
3. CC - список доп. адресатов
4. From
5. Reply To (тольо при ответе)
Поля в одном экземляре:
    6. Date
    7. MessageID
8. Received - поле для сервера: от кого приянял, когда и сам сервер
9. Return Path - поле добавляется SMTP сервером в цепочке машрута и укзаывает куда нужно возвращать письмо

Вложенные файлы шифруются BASE64(раздувает на 30%) и вкладываются в тело письма

Псевдонимы
Адрес, не содержит почтовый ящик.
# Сервис интернет (веб)

    Что являлось изначально аналогом веба (WWW)?

Глобальная система предоставления информации.
Такой системой назывался - <u>gopher</u> (1990) - меню ссылок на файлы, комп. ресурсы.
Позволяла связывать отдельные серверы предосталения информации в единую сеть и
позволяла переходиь между серверами в поисках информации.

Был клиент(ы) и сервер.
В 1991 был разработан WWW в Церне Тимом Бернесом
Он разработал серверную часть и прототип клиентской составляющей

Несколько предпоссылок для перехода от gopher to WWW:
1. В 1993 университет Минессоты требует плату за ПО
2. В 1993 WWW сделали open-source
3. В конце 1993 года появился Mosaic - комбинация из gopher + WWW (Linux, MAC, Windows)

По пути Mosaic пошла компания (1994) браузер поддерживающий только WWW - Opera
Так как WWW начала захватывать просранство со стороны организации появлялись новые браузеры:
В декабре 1994 вышла версия браузера разработана командой (от Mosaic) браузер Netscape Navigator

В 1995 году Microsoft выпустили Internet Explorer

Netscape и Microsoft пытались получить конкуретные преимущества, что приводило к развитию технологий,
какие-то сайты хорошо работали только на определенных браузерах - до 1998

Netscape Navigator работал на 4 версии и 4 версии Internet Explorer

Со стороны разработчиков появилось недовольство - изучать различные технологии и использовать при
разработке одих и тех же продуктов => создан консорсум W3C поддерживались технологии веб серверов и
клиенты браузеров - HTML 4.0 и CSS (1.0, 2.0), но не на уровне стандартов, а на уровне рекомендаций.

В резульатате группа профессиональных разработчиков Web Standart Project решили перевести W3C с рекомендаций
в сторону стандарта. Разработали собственные уникальные технологии

    К чему это привело?
К Microsoft Netscape Navigator прислушались и Microsoft выпустили Internet Explorer 5.0, а Netscape Navigator 5.0
был отложен (пока не согласовали со стандартом)

    Во что он превратился?
Netscape Navigator продолжил свое развитие в новом продукте, поддерживающий стандарты W3C - Firefox

Opera всегда поддерживала стандарты W3C

Все технологии выпускались под W3C - поддерживались со стороны серверных ПО и клиентских (браузерных)

Эволюция концепции WEB выделяют 3 этапа:
WEB 1.0 - статические страницы, слабая ht разметка, малый объем страничного контента, использование
фреймов на сайте, гостевые книги, верстка веб приложений под конкретные разрешения экрана

WEB 2.0 (2005+) - начало эпохи связано со статьей What is WEB 2.0?
Переход от персональных сайтов к блогам - если WEB 1.0 была спекуляция доменными именами
WEB 2.0 - оплата рекламы за кол-во переходов, WEB 2.0 предоставление. WEB стал тоще и тяжелее

WEB 3.0 (наше время, 2015+) - семантическое коммутирование. СИИ


# Технологическая составляющая

Что является основой WEB?
Протокол обмена данных между серверами - HTTP - Hyper Text Transfer Protocol
Протокол для получения данных веб-ресурсов
Он работает по TCP (443), но само взаимодействие межлу клиентом и сервером состоит из
отдельных сессий, которые сразу закрываются после получения ответа от сервера
Сейчас возможна ситуация, когда соединение остается открытым.
Взаимодейсвтие клиента и сервера по порциям, которые могут быть и не связаны (50 ссылок на ресурсы -
50 запросов)
Эта особенность приводит к тому что в HTTP нет памяти - в рамках одного взаимодейсвтия сервера-клиента
нет возможности что-то запомнить в сервреной реализации HTTP. Это приводит к тому, что существует мн-во
реализаций для сохранений Куки, Local storage, Передача данных через скрытые поля. А на сервере - данные
хранения сессии - то что называется сессией не сессия http,
а взаимодействие клиента и веб-сервера.

Сам HTTP памяти не содержит.
С точки зрения участников есть 3 участника - http-proxy, клиент, сервер

Классическая схема установки соедиенения:
отправка соединения от клиента к серверу
получение ответа
закрытие соединения (клиент сайд) к серверу


HTTP:
1. Строка состояния -> средство управления каналом передачи данными
    - Версия протокола
    - URL -> средсто иденификации ресурса. Содержит информацию о
    местоположении ресурса и его название
    - Методы -> GET, POST, PUT, PATCH, DELETE
        В GET обычно отсутсвует тело запроса.
        В POST есть тело запроса (в нем что-то передается)
        PUT предполагалось что это замена ресурса с именем "name"
        DELETE - удаляем ресурс
        HEAD - не возвращает тело ответа - только строку состояния и
        тело заголовка

2. Заголовок (поля заголовка) -> для веб-сервера
3. Тело запроса (отделяется пустой строкой от заголовка)

Схема: URL содержит в себе возможность указания
схема://логин:пароль@хост:порт/путь
Структура HTTP-запроса:
Поля заголовка: название - значение. [User agent, cookie]
Для подсказки серверу для правильной обработки запроса.
Сразу говорит о содержимом тела, таким образом помогает серверу.
тело HTTP-запроса - хочется передать со стороны клиента серверу
либо параметры, либо двоичное содержимое которое интерпретируется как файл

Сервер формирует свой HTTP-ответ.
1. Строка состояния
    * Версия протокола
    * Код ответа -> xxx, [1xx; 5xx]
        * 1xx - спец информационное сообщение
        * 2xx - удачное завершение запроса
        * 3xx - перенаправление - сам сервер обработать не может
        * 4xx - ошибка клиента
        * 5xx - ошибка сервера
    * Текстовый комментарий
2. HTTP-ответ Поля заголовка
3. Пустая строка для отделения заголовка от тела ответа
4. Тело ответа


Сам протокол HTTP - текстовый.
Предусмотрена установка SSL, DLS соединения - обмен между сервером и клиентом,
содержимое зашифровано

Со стороны браузеры ждут установки защищенного соединения.
Соединения устанавливаются путем генерации сессионных ключей сервером случайными
последовательностями.
Клиент проверяет сетификат сервера, сам ключ не передается

Есть возможность аутентификации внтри HTTP:
    * Базовая - через шифрованный канал связи
    * Дайджест - чуть более защищенная
    * Интегрированная - (извне HTTP) использует механизм подтверждения без
    передачи пароля когда клиент говорит кто он, а у сервера и клиента есть
    хэш пароля шифруется последовательсть и передается на сервер.

Cookie - это одно из основных средств HTTP для долговременного хранения данных
на стороне клиента и передачи данных на сервер. Сам HTTP без памяти. Для
решения этой проблемы изобрели куки. Есть определенное хранилище куки -
реализовано средствами браузера. В HTTP-ответе. Клиент может передать куки в
заголовке HTTP-запроса

Set-cookie -> поле содержит:
    Имя - значение
    expires - дата до которого значение параметра валидно
    path - путь
    domain - домен для какого днса сохраняется
это отправляет сервер в заголовке http-клиента
Расмотрим на примере Microsoft IIS [Intenrnet Info Service]

Веб сервер - устройство на котором работает приложение веб-сервера
На одном веб-сервере может развернуто много веб-сайтов
Веб сайт - контейнер, который наполнен контентом.
И IIS - точка доступа к администрированию контента.

Если веб-сайт подразуменвает динамические ресурсы, то внутри одного веб-сайта
может работать application
Веб-сайт - это и  статическое и скриптовое содержимое
В рамках веб сайта приложение работает

Виртуальный каталог - часть пути в URL, который предназначен для расположенного
контента с содержимым веб-сайта.
Если веб-сайт физически расположен в /path/site1
А к нему доступ идет по имени www.compA.ru/
внутри сайта
www.compA.ru/api/
www.compA.ru/doc/
Эта часть может быть за счет маршрутизации внутри сайта, а может с помощью
механизма виртуального каталога

пул приложений - набор правил счетчиков, контроллирующие работу сайтов
управляет рабочим процессами внутри веб-приложений. Конкретно в IISе
есть модуль - WRAS - windows routes activation service - опрашивает процессы
собирает с них дату состояния, если он не отвечает, то гасит рабочий процесс.
А есть возможность использовать мягкий рестарт процесса - recycle
использует намстройки пула приложений. Очерель запроса доступа к сайту.
WRAS не уничтожает процесс. Запускает новый рабочий процесс для того же сайта,
а старый процесс дообрабатывает, возвращает результат и гасится
Установка соединения по защищенному каналу

Сревер и клиент.

Первое что осуществляется - сервер предъявляет сертификат и клиент осуществляет его
валидацию.
Сертификат подтверждает, что клиент образаается именно к тому серверу к которому и хотел
обратиться, чтобы избержать лица посередине (злоумышленник)
TLS - SSL+
У клиента есть сертификаты корневых центров (от серверов) на доменное имя узла.

Генерируется 2 ключа - закрытый и публичный на стороне сервера и на стороне клиента
публичными ключами обмениваются и по нему шифруются сообщения
это Ассиметричное шифрование

теперь нужно сессионное шифрование для трафика
Root - 2, 3, 5 символов
Prime 300 символов
на каждом клиенте и на сервере

Происходит обмен данными - микстурами.
Данные с использованием закрытых ключей и чисел

Микстуры:
Root^(private_S) % prime -> на клиент
Root^(private_C) % prime -> на серверa

(C_M^Private_S) % prime
(S_M^Private_C) % prime
Сервер берет клиентскую, возводит в степень своего ключа и в результате числа получаются одинаковые

Смысл - разными путями придти к одному значению

Если посередине кто-то присутствует, то может установить 2 независимых соединения,
тогда у него 2 сессионных ключа и трафик будет переходить через него



# Архитектура веб-сервера IIS

2 режима - пользовательский и режим ядра.
Разделено на 2 состалвяющие:
в режиме ядра работает драйвер HTTP SYS
принимает запросы по протоколу HTTP
В составе IIS есть 2 сервиса - служба W3SWC и WAS
W3 == WWW
Начиная с 7 версии служба WAS выполняет большую роль

Есть рабочий процесс Working Process.
Есть некоторые этапы обработки HTTP-запроса и обработки HTTP-ответа
Файл конфигурации (состоит из нескольких частей конфигурации ИИС)
Для слежения за рабочим процессом с помощью контейнера - AppPool - не нечто программное, а
мониторинг за рабочим процессом

Функции:
задачи драйвера HTTP-SYS - прием и парсинг HTTP-запроса
Шифрование/расшифрование поддержание зашифрованных каналов тоже за HTTP-SYS
Он же отвечает за управление очередью запросов
Есть очередь в которой собираются запросы, адресованные на один и тот же ресурс (сайт)
Когда поступает запрос HTTP SYS проверяет в кеше есть ли куда передать запрос
(если недавно потупали запрос на текущий сайт, то просто передаст эти данные на
рабочий процесс, если нет, то передает информацию куда адресован запрос - HTTP, HTTPS, порт, IP, заголовок
из URL имени запроса)
дальше передает в WAS
WAS определяет какой сайт должен обработать запрос.
По тем данным, которые получаются у драйвера и настрайка привязок у веб сервера WAS понимает
куда перенаправить запрос. Если такой процесс у URL есть, то возвращает информацию куда надо
передать, если нет, то запускает эту службу. Собирает конфиги для сайта, объединяет с конфигами сервера
и этот единый конфиг копируется и защищается правами доступа
Доступ к конфигу разрешается только рабочему процессу. Сведения передаются до HTTP SYS.
У него есть кэш с соответствием привязка-рабочий процесс
Дальше драйвер HTTP SYS передает HTTP-запрос по указанному рабочему процессу.
HTTP запрос переходит через цикл этапов обработки процессов.

После обработки драйвер берет следующий запрос на обработку.

Задачи служюы WAS
Управление конфигом перед запуском, управление процессами, запуск
контроль ресурсов URL приложений
по достижении определенных событий перезапустить старый рабочий процесс.

В заадчи рабочего процесса - работа с was (предосталвение данных о своей работе)
Передача которая встроена внутри приложения.
Когда обработка доходит до какого-то момента, то происходит передача управления
веб-приложению - аутентификация, авторизация, журналирование.

Такой режим работы называется традиционным конвеером работы.
Есть вариант строенного (интегрированного режима работы)
приложение может подписываться (части подписываются на события выполнения этапов конвеера)
По завершении выполнится код приложения.
Код приложения модет выпонляться по чуть-чуть на каждом этапе разработки
То в каком режиме работы работает процесс (стандартный или интегрированный) настравивается
на уровне без-приложения
Рабочий процесс запускаемый службой WAS начинает работать

Кто должен осуществить обработку?

1. Протокол HTTP/HTTPS
2. IP адрес (на какой ip поступил запрос) - значение, либо все
3. Порт TCP - конкретное значение
4. Host header (hh) - DNS имя с запроса - значение, либо пусто
На сервере публикуется несколько сайтов.
Нужно чтобы комбинация была уникальна
Например:
Есть порт, но hh пустой. А есть тот же самый порт и разные hh.
Если будут дубликатные пакеты, то не получится разделить.


Разделения привязок.
По IP трудно
По портам можно, а вот публично трудно реализуемо.
Единственный вариант - hh
пусть Все 3 параметры одинаковые, но добавляется еще один параметр
www.companyA.ru
www.companyB.ru
www.companyC.ru
В DNS все эти имена будут разрешаться в один и тот же ip адрес.
Запросы будут поступать на один и тот же ip адрес.
При публиуации множества сайтов их нужно разделять по заголовкам хостов.
Для одного сайта может быть несколько привязок.
Технология удаленного доступа к сети

Что это?
В различных организациях возможна работа сотрудников -> нужен доступ к сети

NAS - Network Access Server

LAN
NAS -> File
    -> DB


Способы подключения:
    1. Клиент (с модемом)
    2. У организации есть модемная стойка (мноо модемов)
    3. Через коммутируемые линии связи устанавливается соединение между клиентом
    и сервером.
    PSTN или TSDN
Идея в том, что есть общая сеть.
Большое кол-во кабелей и коммутаторов - они из другой точки где есть телефон
можно установить канал связи в другой точке где есть телефон -> непрерывная связь
по двум проводам. Цифровой преобразуется в аналоговый, передается по проводам.
Появилось потому что не было сотовой связи.
Для каждого входящего подключения необходимо иметь устройство

Современный вариант - опорная сеть (города, провайдера, кампуса) - сетевая
инфраструктура к которой можно подключиться. Есть клиент, который может получить
доступ. Устанавливаем защищенное соединение между клиентом и организацией - VPN.
Внутри VPN-соединения эмулируется соединение точка-точка (было по коммут. линиям)
связи. Файловый ресурс могут взломать - получить к внутреннему компу доступ и с
него получить доступ к ценному ресурсу. Когда используем удаленное подключение
аутентифицируемый получает точно такой же доступ к сети как и комп организации.
Оченб важный аспект - обеспечение безопасности.
Есть много способов аутентификации.

1. PAP - password auth protocol
2. SPAP - shiva password auth protocol - передается зашиврованная версия, а не
сам пароль
3. CHAP - challenge handshake auth protocol - не происходит передачи пароля ни
в каком виде. Есть клиент, сервер. У сервера бд в безопасности, в которой
хранятся пары логин-пароль в виде кеша - MD5. Со стороны клиента есть логин и
пароль, который пользователь ввел.
У клиента:
Login
password
-> MD5

Сервер проводит идентификацию по базе и находит поьзователя, возвращает 8-байт
последовательности. Клиент с использованием хеша MD5 вычисляет функцию и получает
строку. Добавляет 5 нулей и формирует 3 семи байтовых ключа
8 байт шифруется по протоколу
и получаем 3 восьмибайтовой последовательности 8+8+8 -> объединяются и передаются
на сервер.
Сервер получает строку, которая включает в себя 3 составляющие и сравниваются
между собой. Если совпадают, то принимается, если нет, то отклоняется.
4. MS-CHAP
5. MS-CHAPv2
6. EA - extended auth - использует не соотв. логин-пароль, а средства
биометрической аут.
При согласовании протокол EA будет несогласован, так как клиент неподдерживает
протокол. Если на стороне клиента указаны протоклы кторые на стороне
сервера не поддерживаются, то установка не поддерживается.
Есть один режим доступа к сети
Если злоумышленник знает логин и пароль, то ничего не сделать. Если возникнет
попытка подбора пароля (брут форс), то на сервере есь журнал безопасности -
события попытки подключений (как полжительные попытки так и отрицательные)
В этом журнале формируется набор записей, анализируя которые админ поймет, что
злоумышленник пытается взломать.
По логам можно отследить что сотрудник подлючается и работает. Если сервер
доступа к сети один, то мониторинг безопасности позвоялет выявить и среагировать
на эти попытки.
Если организация большая и имеет много точек подключения, то каждая из этих точек
будет иметь свои настрйоки подключения и свою безопасность. Мониторинг ряда баз
безопасности... В этом случае было бы удобно средство управления всеми точек
доступа к сети.
RADIUS - все сервера доступа к сети настраииваются как клиенты сервиса.
Имеет общую для всех точек бд, может работать в гетерогенной сети.
В RADIUS есть возможность управления разными базами данных безопасности.
В этом случае сервер доступа к сети делегирует полномочия к сервису. Сервер -
только точка подключения. Фактическую аут. ведет RADIUS, всё в одной точке.
RADIUS-proxy - когда несколько RADIUS и он уже маршрутизирует клиентов к
серверу RADIUS. RADIUS разрешает подключение к серверу.

Для доступа по коммут. линиям связи используется PPP. Peer-to-peer protocol.
PPP содержит стек протоколов:
    1. LCP - Link Control Protocol - контроль установки и проверки разрыва
    каналов соединения
    2. NCP - Network Control Protocol - их несколько, каждый для своего протокола
    сетевого уровня.  Управление в конкретной реализации интерфейса. Сам PPP
    инвариантный для взаимодействия клиент-сервер. PPP поддерживает все те
    протоколы аутентификации, согласование.
    1. Установка соединения
    2. Аутентификация
    3. Обратный звонок
    4. Установка сетевых параметров (NCP) - назначение IP, передача MTU,
    адрес DNS, gateway - инициализация сетевого адаптера на стороне клиента.
    5. Передача данных

После установки соединения протокол PPP. Внутри себя пакет PPP содержит
протокол (IP-пакет упаковывается в кадр и отправляется по PPP);
В ЛК есть лекции + лабы + ИДЗ


Балл
+ 6 лаб (10 * 6=60б)
+ ИДЗ (20б)
+ Тесты (4 * 5=20б)
лабы в среде ВМ настраивать вирт. полигоны и настраивать службы

Экзамен состоит из 2х частей:
1. Практическая часть - до экзамена - у каждого дан полигон, сделать тоже самое что и в лабах = 40б
2. 2 теор. вопроса = 60б

# Введение.
Что является объектом управления (администрирования)? - комплекс программ и вс

Область ответсвенности админ. - ПО

Как ЭВС видит пользователя(бухгалтер, менеджер)? - Учетная запись, в контексте которой, юзер работает с ПО
Учетная запись характеризуется логином + паролем + прочее.

Как появляется учетная запись? В ходе регистрации в учетной системе.

Пользователь хочет войти в систему. Какие процессы здесь протекают? Идентификация (логин+пароль) - определение в бд безопасности пользователя с такой учетной записью
После идет аутентификация (подтверждение владением учетной записью (пароль))
Авторизация - если все данные прошли проверку.

Пользователи заходят в систему за доступом к ресурсам. Ресурсы (логические и физические)- объекты, используемые в рамках бизнес-организации
Файловое хранилище - как пример физ. ресурса
Сетевая папка - пример логического ресурса

Права доступа - различаются от вида ресурса.

Принцип минимальных полномочий.
Если у пользователя есть полные права на ресурс, то он ялвяется точкой опасности, такие вещи можно ограничивать с помощью установок прав доступа, выше,
чем пользователь имеет в системе

В чем состоят права и как они хранятся.
Набор прав хранится в
+ ACL (Access Control List):
    + ACE
        + Право (создать/удалить/...)
        + Действие (Разрешить/Запретить)
        + Субъект (Пользователь/группы/роли)

SACL - используется в процессе аудит. Мониторинг процессов доступа к ресурсу, для того чтобы иметь информацию о действиях пользователя
(что пользователь пытался сделать (кто, когда, получилось или нет))
Зачем иметь записи о неудачах?

DACL
Для того чтобы несколько пользователей могли использовать один ресурс, им можно поделиться (появляется логический ресурс, с которым могут взаимодействовать другие)

Функции администратора:
1. Учет пользователей
+ Регистрация
+ Назначение прав
+ Удаление пользователей:
    Как админ узнает уволенного сотрудника для удаления?
2. Управление доступом к ресурсам
3. Резервное копирование и восстановление данных
4. Установка и поддержка работоспособности ПО и железа


Золотые правила администрирования
+ Никогда не проводи эксперименты на работающей системе без резервной копии, а лучше это делать на оборудовании для тестов
+ Всегда документируй действия администратора
+ Если можно переложить часть работы на подчиненного, то лучше переложить её на него, но если ты не уверен, что он справится, то делай сам
+ Пользователь, имеющий больше прав - несет больше ответственности
+ При работе с ресурсами и ЭВС в качестве пользователя необходимо использовать учетную запись обычного пользователя.
+ Регулярно меняй пароль учетной записи администратора

Составные части ИВС - обеспечение:
+ аппаратное - вычислительные установки (узлы) для выполнения задач
    + Серверы - компьютер для совместного использования. Важна отказоустойчивость - возможность продолжение работы в случае сбоев аппаратного обеспечения
        Дублирование - использование системы RAID для дублирования данных
            RAID 0 - чередование, 2 диска, но в системе выглядят как 1 и нумерация распределена между дисками. Если выхоидт из строя один диск, то весь том тоже выйдет из строя.
            Обычно так хранят неважные данные
                0   1
                2   3
                4   5
                6   7

            RAID 1 - зеркальные 2 диска - скорость записи не меняется, ускоряется скорость чтения, повышается отказоустойчивость
                0   0
                1   1
                2   2
                3   3

            RAID 5 - 3 и более диска, ессли выходит из строя один диск, то за счет контрольной суммы можно использовать остальные
                0   1   *
                2   *   3
                *   4   5

            RAID 10 - есть 2 диска в режиме 0 и еще 2 в режиме зеркалирования

    + Рабочие станции

    Читать до NET BIOS (служба поддержки Инф сети)
# Служба поддержки сети

## Имена локальной сети

В локальных сетях взаимодействие хостов используются - MAC-адресами

Компьютеры идентифицируются - IP-адресами
IP-адреса - сетевой уровень

IP -> MAC при помощи протокола

Кроме адресов компьютеры имеют имена (DNS)

Если днс нет, то локальные имена в виндоус придуманы уникальные имена (NetBIOS-имя)

Для разрешения NetBIOS-имен существует WINS - задача, как и у ДНС, только в сетях организации.
В линукс-сетях для разрешения локальных имен используется mDNS (multicast)
Если есть лок. сеть, но нет ДНС


## Варианты NetBIOS имен
NetBIOS имя - плоское имя до 15 символов в длину.
Сейчас имя хоста и NetBIOS одинаковые

1. На каждом комп. есть кэш имен.
2. LMHOSTS - содержит пары: имя-ip
[
    3. Широковещательный запрос - если хосту нужно разрешить имя - у кого имя {hostname}? - У меня! - Заносит в кэш и взаимодействует по ip
    4. WINS - спец. служба, отвечающая за работу с NetBIOS
]

Всего 4 типа узла NetBIOS

1. B-узел - только широковещательные запросы
2. P-узел - только с сервером WINS (без широковещательных)
3. M-узел - снача широковещ. запрос, затем запрос WINS
4. H-узел - снача к WINS, потом широковещ. запрос


Система имен NetBIOS больше, чем просто взаимодействие юзеров в сети по именам
Её идея в том, что с помощью имен комп. может объявить о тех сервисах, которые на нем доступны
Система bonjour - узел сам о себе сообщает

И в кэше и в бд WINS хранятся
имя[код]
имя - символьное имя
код, если 00h, то это точка - уровень сети неизвестен
20h - хосту разрешен доступ к расшейреным файлам
01c - котроллер домена

Хост пользуется не одним именем, а столько сколько сервисов он предоставляет

## Как хосты регистрируют

Когда комп. загружается то он регистрирует свое имя
в широк. NetBIOS-запросе.
Если уже такое имя в сети есть, то ответ по широк. отправляется тому комп. (уже используется - отказ)

Другие комп. сохраняют в кэш и в дальнейшем используют

Зачем сделан счетчик?
И почему в кэше это нельзя держать
В кэше могут быть старые записи - станет неактуальным

Широковещательные запросы норм работают в небольших сетях (10-15 комп.)

## Участники

Сервер - ведение БД, разрешение NetBIOS-имен, регистрация NetBIOS-имен + контроль уникальности
Клиент - ПО на комп. - к какому серверу WINS клиент обращается.
WINS-proxy - обеспечить работу клиентов, которые не работают с WIN-сервером напрямую


Служба WINS работает в динамическом режиме

NetBIOS-клиент после регистрации имени ведет отчет времени регистрации имени в WIN-сервере и в течении промежутка пытается его обновитьклиент
после регистрации имени ведет отчет времени регистрации имени в WIN-сервере и в течении промежутка пытается его обновить


То, что видим в сетевом окружении отображается в виде списков просмотров.

Основной обозреватель сети - ведет список живых компов.

Механизм назначения обозревателя

## Какие хар-ки используются?

* Протокол
* Версия оп. системы
* Статус основного контроллера домена
* Статус WIN-сервера
* Предпочитаемый главный обозреватель
* Текущий главный обозреватель
* Бывший главный обозреватель (замена текущего)
* Работающий резервный обозреватель (на каждые 32 комп. сети формируется обозреватель)
* Время непрерывной работы
* NetBIOS-имя

Среди всех обозревателей выбирается обозреватель домена - каждый основной обозреватель подлкючается к обозревателю домена и получает список всей сети
Если сеть большая:
    Обновить инфу, отправить новую, новый обозреватель получает новый список
КД - 12 минут


Тестирование по NetBIOS - 5 вопросов.
Когда компов было не так много и в основном были мейн фреймы, вполне хватало ручного ведения учета хостов
и изначально использовался файл HOSTS - для настройки адреса комп. и его имени.

DNS - получить по имени IP, решает задачу запоминания IP адреса для человека.
2 сложности:
    Основной функционал - разрешение. В рамках чего

    Обеспечение уникальности имен.
    Большое кол-во ответственных за назначение имен. И все должны договориться.

    Всю систему ДНС можно представить в виде дерева.
    В корне дерева является пустсой элемент
    Домены региональные - ru, us, ... + com, org, edu, ...
    За домен точка отвечают: IANO, InterNIC - чтобы домены первого уровня были разные
    Управление доменов первого уровня дилегируются другими органами - например, органы страны.
    * -> ru, us, com, org, edu
    ru -> yandex, mail, lipetsk - можно регистрировать любой домен, согласовываются с ru
    com -> google, microsoft - домены второго уровня
    lipetsk -> stu

*
 ├──ru      <-- высота
 │   ├──yandex
 │   ├──mail
 │   └──lipetsk
 │       ├──stu
 │       └──serv01
 ├──us
 ├──com
 │   ├──google
 │   └──microsoft
 ├──org
 └──edu




hosts
 └──local
     ├──int
     ├──internal
     └──loc


Преимущества - можем дать домен любой организации.
2 соседних ip могут принадлежать различным доменам
Ведь домены и адреса никак не связаны. И их соответствие хранится в виде таблицы DNS - имя-ip_адрес

Центральными элементами системы днс являются днс серверы
Центральными узлами являются серверы ДНС. Они и разрешают запросы клиентов:
какой ip адрес у этого имени?

Какие возможны варианты хранения о пространстве имен DNS
На примере lipetsk.ru - вся на одном сервере -> вся информация о дочерних доменах +0 хранится там. Как только решим добавить комп в stu

Lipetsk.ru не знает ничего о хостах своих доменов. И когда регистрируется домен - compA, то за этот домен отвечает DNS-сервер

Связи между серверами располагаются сверху-вниз

Сервера, отвечающие за домены нижележащего уровня и всё!
Все DNS сервера знают корень, отвечающие за все высокие домены

Локальный компьютер знает ip-адрес DNS сервера провайдера.
www.google.com
А какой ip у www.google.com? - DNS сервер провайдера смотрит у себя в кеше - если есть, значит вернет и возвращает клиенту ip адрес корневого DNS сервера
Клиент посылает запрос к корневому DNS серверу. Корневой не знает. Смотрит первый уровень иерархии - www.google._com_
А com-то знает про google, следовательно отсылает запрос ему, а он уже рещает отвечать ему или нет

Если DNS сервер не знает куда послать, то он смотрит кто его обслуживает. В случае неудачи, результат будет отрицательный

Вторая схема - рекурсивная
Если все сервера настроены отвечать в рекурсивном режиме

Первый запрос идет DNS-серверу провайдера. Ответ на DNS сервер он не знает -> посылает запрос корневому DNS-серверу.
При работе в рекурсивном режиме посылает запрос для com. google.com находит у себя ответ. И результат по обратному маршруту доходит до клиента

Корневые DNS-сервера никогда не работают в рекурсивном режиме.
Используется смешанная схема - у корневых DNS-серверов никогда не формируется кэш

В системе DNS широко используется кэширование и если в кэше есть ответ, то его отправит из кэша

При переходе на новый ip, доменное имя не поменяется, но из-за кэша запросы все равно будут приходить на старый адрес
FIX: обновить кэш


Одна зона может обслуживаться несколькими серверами. Один DNS сервер может хранить несколько зон DNS
Если есть 2 сервера - serv01, serv02, то compA.ru может храниться

┌─────────────────┐┌────────┐
│compA.ru         ││compB.ru│
└┬───────┬───────┬┘└┬───────┘
┌▽─────┐┌▽─────┐┌▽──▽──┐
│serv01││serv03││serv02│
└──────┘└──────┘└──────┘
'
    compA.ru -> serv01
    compA.ru -> serv02

    compB.ru -> serv02

    compA.ru -> serv03
'

Между первичными и вторичными серверами может происходить синхронизация - вторичные сервера спращивают у первичных об обновлении информации

Существует 3 типа зон:
первичная - зона на сервере
вторичная - на вторичных серверах
третичная - заглушка - нужна для перекрестных связей, чтобы mail.ru мог напрямую обратиться к google.com

Первичная и втоичная - идентичные зоны

Если зона compA вторичная, а compB - первичная

Зачем зоны размещать на нескольких серверах
    Резервирование
    Балансировка нагрузки

Это были типы - зоны, где есть имена - зоны прямого просмотра - основная сост. DNS. Разрешают запросы типа а какой ip-адрес у этого имени?

Есть и зоны обратного уровня - а какое имя у этого ip-адреса?

12, 17, 34, 195, inaddr, arpa

* inaddr,arpa
 ├──1
 ├──2
 ├──3
 ├──...
 └──195
     ├──1
     ├──...
     ├──10
     ├──...
     └──34
         ├──17
         │   └──12 - RQDN
         └──18


[*] inaddr,arpa
 1
 2
 3
 ...
 195
  1
  10
  34
   17
    12 - RQDN
   18
#
LAN 192.168.0.0/24

serv01 serv02
                GW  -> Internet
pc01    pc100
    serv03  serv04



Owner
TTL
CLASS   (IN) - все записи относятся к одному классу - интернет? или (CH) == CHAOS
Type
RData - наполнение зависит от типа



# Содержимое файла зоны DNS

@ In SOA -> [первичный сервер] serv01 -> [ в днсе указывается полное доменное имя ] serv01,compA local -> лицо, ответственное за ДНС ->
(
26 - serial number
, 900 - refresh rate -> то, как часто обращаются к обновлению
, 600 - retry - если синхронизация неудачна, то повторить через retry
, 86400
, 3600
)

Есть один первичный и несколько вторичных DNS-серверов
Серийный номер для понимания что серийная копия зоны устарела, копии имеют доступ к зонам в виде [get DNS1.serNum -> Transfer Zone]

SOA - указывает только на первичные

___В нашем случае
serv01 - main
serv02 - вторичный

@ IN NS serv01,compA.local
@ In NS serv02.compA.local

Если сервер не записан среди перечисленных, то про него никто не знает

### таблица соответсвия DNS и ip:
┌─────────────────────────┐
│serv01 IN A 192.168.0.1  │
├─────────────────────────┤
│serv02 IN A 192.168.0.2  │
├─────────────────────────┤
│pc01 IN A   192.168.0.101│
├─────────────────────────┤
│pc02 IN A   192.168.0.200│
├─────────────────────────┤
│GW   IN A   192.168.0.254│
├─────────────────────────┤
│GW   IN A   192.168.1.254│
├─────────────────────────┤
│serv01 IN A 192.168.1.3  │
├─────────────────────────┤
│serv02 IN A 192.168.1.4  │
└─────────────────────────┘



AAAA - ipv6 или A6



CNAME - canonical name - содержит псевдоним (например www)
В части данных оно содержит название полного доменного имени хоста

┌──────────────────────────────────────┐
│www     IN  CNAME   serv03.compA.local│
├──────────────────────────────────────┤
│info    IN  CNAME   serv03.compA.local│
├──────────────────────────────────────┤
│help    IN  A       192.168.1.3       │
├──────────────────────────────────────┤
│mail    IN  CNAME   serv04.compA.local│
└──────────────────────────────────────┘

Во всех остальных записях используются полные символьные доменные имена - разрешаются в записи A


compA.local
@   IN  SOA serv01.compA.local (...)
@   IN  NS  serv01.compA.local
@   IN  NS  serv02.compA.local
@   IN  NS  serv03.compB.local

Записей хостов здесь нет:
serv01  IN  A   192.168.0.1
serv02  IN  A   192.168.0.2
Хост может сразу отправить запрос напрямую, не через иерархию dns, а к перечисленным серверам
~~~
@ - запись принадлежит зоне DNS
~~~
#### Продолжение прошлой лекции

Зона ДНС
0.168.192.

Запись SOA

@   IN  SOA  serv01.compA.local     // <- На первичный сервер для этой зоны DNS
@   IN  NS   serv01.compA.local
@   IN  NS   serv02.compA.local

Основное наполнение зон  - запись типа ptr - между ip и именем
Где owner пишется недостающая часть адреса, добавив которую мы получим полностью перевернутый адрес

Для serv01 1
┌────────────────────────────────┐
│1   IN  PTR  serv01.compA.local.│
├────────────────────────────────┤
│2   IN  PTR  serv02.compA.local.│
├────────────────────────────────┤
│101 IN  PTR  pc01.compA.local.  │
├────────────────────────────────┤
│200 IN  PTR  pc100.compA.local. │
├────────────────────────────────┤
│254 IN  PTR  GW.compA.local.    │
└────────────────────────────────┘

Дальше по тем же самым схемам ДНС хотим узнать имя у ip
делаем ДНС запрос, переворачивается ip, добавляется суффикс (зона днс) и отправляется запрос
До сервера доходят запросы и он возвращает.

Когда в сети есть ДНС сервер как настроить клиентов?
У них должны быть несколько DNS серверов, чтобы разрешить запрос

Как должны быть настроены клиенты?
Для интерфейса можно указать несколько ДНС серверов

Все ip адреса DNS выстраиваются в порядке приоритета - список ДНС серверов

Клиент посылает запрос первому ДНС серверу
Если цепочка с которой вернулся ответ - не знаю, то посылается следующему
А если он ввообще не отвечает, то он выкидывается на время
Потом возвращается в список доступных DNS серверов
Можно указывать любые ДНС серверы клиентов

Если в сети DNS сервер есть, то надо указывать клиента
Клиенты должны быть заведены на нашем DNS-сервере

compA.ru - домен, который мы купили
У нас есть почтовый сервер на внутреннем сервере serv04
Для того чтобы к почтовому серверу приходили запросы от клиентов находящиеся в интернете нужно чтобы была некоторая
запись в домене compA.ru
MX - должна указывать на сервер mail.compA.ru
@       MX  mail.compA.ru
mail    A   195.11.11.23


.

┌─────────────────────────┐
│pop     A   192.168.1.4  │
├─────────────────────────┤
│smtp    A   192.168.1.4  │
├─────────────────────────┤
│@       MX  mail.compA.ru│
├─────────────────────────┤
│mail    A   192.168.1.4  │
└─────────────────────────┘
^
|
|
Когда и зачем нужно иметь 2 зоны ДНС с одним именем


Сервер рабоает с записями

Запрос послали, разрешили, вернули 0

nslookup - можно выбрать сервер и писать запросы DNS (не использует кэширование на клиенте)
# Инфраструктурная служба - DHCP

Вручную указываем IP, структ. - те настройки которые надо задать для сетевых адаптеров, чтобы компы работали
Нужна уникальность ip адресов.

при ручной конфигурации ip адресов - Если возникает проблема что надо что-то поменять, то придется заново пройти перенастройку всех компов

DHCP:
1. Назначить адрес ip
2. Передать ряд настроек интерфейсов сетевых адаптеров
3. Обойтись без админа

2 участника:
1. DHCP сервер - отвечает за центр. хранение настроек, за ведение бд выданныех ip адресов, клиенты к нему обращаются, а он отдает свои конфиг. настройки.
2. DHCP клиент - Если что-то выдаем динамически, то нужны механизмы для отказа/продления

Спецификация не подразумевает совместную работу нескольких DNS-адресов.
Но такая возможность есть, но они не должны контактировать (не мешать)

Еще один участник - объект трансляции DHCP
Клиент должен получить ipaddr в тот момент когда у него его нет. Клиент не способен работать в ... Необходим механизм позволяющий
клиентам обращаться к адресам
Послать широковещательный запрос. Здесь главная проблема - ограничены одним сегментом сети -> Если в некоторой организации ip имеет несколько сегментов,
то нужен в каждом сегменте свой DHCP сервер

DHCP имеет прослушиватель - агент трансляции - работает на маршрутизации и является частью протокола на маршрутизаторе

Для того чтобы клиенты могли взаимодействовать в DHCP сервером то на сервере настроено что агент ретрансляции отправляет к DHCP серверу - <u>DHCP-Relay</u>,
то есть позволяет получать ip адрес клиентам, которые находятся в разных сегментах

Пока клиент не получил ipaddr общение возможно только на канальном уровне.
На сетевом только широковещательный, а DHCP-Relay посылает ответы


<u>Основные понятия </u>
Основным объектом который натраивается в DHCP - ялвяется область - scope - непрерывное пространство ipaddr которым управляет DHCP сервер

Супер-область - позволяет объединить несколько областей в одну

## Зачем нужна область?

Клиент посылает широковещательный запрос для получения ipaddr
Этот запрос ловит либо сервер (знает идентификатор сети), либо DHCP-Relay (знает)
DHCP должен определить какой адрес выдать
Широковещательный запрос: у сервера по адресу интерфейса сервер знает куда отправить запрос

Если pc01 запустился - посывлает широковещательный запрос дай мне ipadd. Сервер понимает что клиенту надо выдать ip, который коррелирует с его текущим
А должен ли  что-о ему выдавать? Среди настроенных областей находит подходящуу, в которую поступил запрос
Если запрос поступает не лично от сервера, а от агента ретрансляции. То он понимает на каком интерфейсе запрос был получен
И сервер уже для этого адреса ищет подходящую область (поиск по маске сети)

Важно, чтобы у сервера была облать

Для того чтобы сервер мог выдавать адреса клиентам, то нужно иметь соотв. маску
У клиента нет никакой информации.

В сети есть устройства со статич. ip адресами.
Чтобы их исключить указываются диапазоны исключения - exclusion

Укажем, что адреса
192.168.0.1-10/24 - для таких-то
192.168.0.200-220/24 - для таких-то
Из области выразем те ipaddr которые сервер гарантированно выдавать не будем
Все что осталось - пул ipaddr, любой из которых сервер может выдать

С пулом сервер и работает


Когда к серверу приходит запрос от клиента, то он может дать рандомный адрес из пула.
Потом клиент начинает обращаться за ipaddr, отдает его и говорит что он выдан

По запросу клиента может выдать любой адрес из пула

Иногда необходимо чтобы клиенты получаели не произвольные, а конкретные ipaddr

<u> Механизм резервирвования </u>
Вот этому клиенту вот такой ip addr
Клиент же резервируется по MAC-адресу -> ipaddr

Резервированные адреса - любые из пула

Когда клиент запросил ipaddr - произвольный либо из резерва
Сервер выдает адрес на период аренды и заносит запись в таблицу аренды ipaddr
как толкьо срок аренды истек, сервер возвращает адрес и клиент должен прекратить использование этого адреса
По истечению половины вермени DHCP клиент посылает DHCP серверу запрос на продление адреса и новый срок аренды сдвигается
Самое главное, чтобы оба были online
Если клиент выключается вне указанного срока, то при ключении придется запросить новый ipddr

Если у сервера есть возможность выдать тот же адрес, то он его выдаст. Иначе возьмет другой из пула.

Срок периода аренды очень важен.

Если сеть с частоменяющимися клиентами, то время обновления нужно указать поменьше

Можно задать не только зарезервированных ipaddr, но и соотв. настройки


Широковещательный запрос - запрос обнаружения DHCP сервера

Мне нужен ipaddr!

DCHP сервера проверяют могут ли предложить свободный адрес и отсылают DHCP-Request
Клиент выбирает подходящий адрес
# DHCP

...

Выбирают из своего пула адреса и посылают ...
Без ip адреса можем отправить предложения по MAC адресу
Тот сервер, который сделал предложение понимает, что оно принято

Адрес не может быть никому выдан
Все серверы, чьими предложениями клиент не воспользовался, возвращают ip адреса и отправляет (серв с ip) квитанцию и начинает аренду ip
Если не было процедуры продления, то клиент независимо от сервера может отказаться от ip-адреса

Если клиент за время аренды загружается, то начинается процедура получения нового адреса,
в течении срока аренды клиент пытается обновить ip-адрес
Когда клиент должен высвободить ip-адрес, все равно выпадает из сетевых взаимодействий. Процедура продления безопасна и сопровождается направленно
(не широковещательный опрос)

Предполагается что есть 1 сервер и он отправляет ip-адреса
2 сервера не взаимодействуют и нет такого протокола, потому что если 2 сервера будут часто обмениваться данных, то возможна выдача дублированных адресов
Механизмы обеспечения и взаимодейсвтия 2х ip серверов

## 3 режима
Когда какой-то клиент отсылает запрос на получение ip-адреса, то оба сервера формируют свои предложения
Только у каждого свой пул (которые не перекрывают друг друга)
Один забирает, второй высвобождлают.

Когда один из серверов не работает, тогда клиенты с истекающим периодом аренды посылают новый запрос, второй сервер подхватит и выдаст адреса из своего диапазона

## Преимущества DHCP:
уменьшается объем ручной работы - настройками можно управлять централизованно

### Минусы DHCP:
Если компьютеры получают ip адреса случайным образом, то администратор не знает адреса своих клиентов
В таком случае надо работать по именам (WINS, Bonjour)

# Служба обеспечения DHCP сетей

Прокси - сервер или сервис задача которого выступить посредником между клиентаом локальной сети и внешними хостами
Прокси в интернете не обеспечивает безопасность.
Таким образом обходят проблемные моменты
Когда подключаемся по прокси ко внешней сети, то все запросы идут от прокси
Есть возможность обойти блокировку и скрыть что к ресурсу обращаемся мы

Точка атаки размазывается по всем клиентам, любой клиент внешней сети может быть атакован
FireWall может помочь

Если есть прокси, то клиент посылает на прокси запрос, который он хочет получить с внещнего сервера, прокси получает ответ и полностью его распаковывает (HTTP Request)

В этой точке он может проанализровать контент и если все норм, то через канал с клиентом отправит его
Обеспечивает точку, в которой из одного соедиенения в другое перекладывается пакет

Использование прокси в малых сетях
Когда был компьютер, на котором был модем, с помощью которого устанавливалось соединение и получали иетнрнет
Так как нет NAT-устройства, в этом случае устанавливалось прокси на модем и клиент отправлял запрос к прокси
Устройтсво с NAT заменили такое устройство

1. NAT-прокси
На какаом уровне работает NAT-прокси? На сетевом
Не может анализовать трафик, выше ip-уровня не поднимается

2. HTTP-прокси для организации работы клиентов с помощтю браузеров протоколом HTTP
клиент должен быть настроен на прокси
3. HTTPS-прокси работает по протоколу HTTPS:
шифрование. Прокси не может просматривать трафик клиентов
Один канал его с клиентом, второй канал его с внешним сервером.
Трафик шифруется и прокси выступает посредником в процессе согласования ключей
В контент он не лезет и кэшированием заниматься не может
Что передается он не знает

4. FTP-прокси (File-transfer protocol)
Знает протокол, умеет контролировать целостность, умеет организовывать взаимодейсвтие с клиентом
Клиент осознанно работает с прокси
Подразумевает докачку, разрыв соединения.

5. Mapping proxy - протокол транспортного уровня
ВСе запросы на этот порт приходящие отправляем на внешний хост X, а клиентам внутренний сети указывается адрес и порт Mapping proxy
Клиент думает что подключается к своему серверу, а на самом деле посылает к прокси,
а ответы возращаются клиенту. Клиент думает что работает с сервером напрямую, но на самом деле есть разрыв в прокси
Для анализа трафика и избегания прямого взаимодейсвтия с сервером
чтобы клиент общался с сервером не напрямую, а через прокси, то нужно запретить ему взаимодействие с сервером напрямую
Клиент с ним установил соединение, а Mapping-прокси без разницы с каким протоколом работать. Он лишь передает TCP-пакеты.

6. SOCKS-proxy
Универсальный, но клиенты с ним взаимодействуют через систему команд
<!-- HTTPS-proxy не может кэшировать данные -->

# Фаерволл и защита сети

По брандмауэру осталось осмотреть роли - стратегию многоуровневой защиты сети
Есть несколько уровней защиты сети
Первое кольцо защиты - граница с сетью интернет
Брандмауэры (фронтэнд) - блокируют <u>трафик (пакеты) с интернета</u> (внешней сетью)
Внутреннее кольцо - бэкенд фаерволлы
Почему 2 кольца?
Между ними - сети периметры - демилитаризованная зона

Для размещения ресурсов, которые должны быть доступны из внешней сети
Все они размещаются в демилитаризованной зоне

В качестве бэкенд-фаервола используется фаервол фильтрации для <u>внутренних приложений</u>
.

Третье кольцо - FW отдела - граница сетей, объединяющая фрагменты сетей (могт быть защищены fw):
возможны варианты:
изнутри можно, снаружи нельзя.
FW защищает сеть с корпаративным имуществом

Когда внутри организации есть чужеродный орган
чаще всегоо какие-то купленные внешние системы, которым не всегда можно доверять

Задача fw - запретить доступ из внутренней сети

В правилах фаерола это прописывается.
Четвертое кольцо защиты - компьютеры, на которых стоят FW.
Если троян попал на ПК, то FW на границе не поможет, только персональный FW

Их задача - разрешать весь трафик из пк в локальную сеть, а вот входящие запросы блокируются

Выделяют брандмауэр филиалов(удаленных подразделений) - на внешнем кольце.
Функции установки канала vpn является функцией FW - являются vpn-тоннелями.

Если внешний FW сетевого уровня, то он не внесет значительного импакта на скорость.
FW вызовет задержки на прикладных уровнях, не на сетевых
<!--- Электронная почта ---!>
имя ящика - @ (коммерческая add) + почтовый домен
почтовый домен - система в которой должна быь запись MX, которая указывает на сервре входящей почты
Если там её нет, то без ручной маршрутизации пользоваться не получится

CompanyA.ru

Запись MX, которая будет совпадать с доменом и будет указывать на сервер, который является обработчиком почты
CompanyA может трактоываться как имя хоста в зоне ru

Участники системы эл. почты:
1. MTA (mail transport agent) - сервис отвечающий за маршрутизацию, разбор адреса доставки, отправку почты на сервер, 
опрос DNS (куда?) - центральное ядро эл. почты (сервер эл. почты)
2. MDA (mail delivery agent) - программа внутри рабочего сервера - часть почтовых серверов занимаются доставкой почты:
    1) SMTP для передачи писем между серверами
    2) local - для помещения письма в рабочий ящик
    3) Prog - программный агент доставки (по приходу письма выплнить скрипт)
3. MUA (mail user agent) - программа юзеров для отправки и прочтения писем

Протоколы POP и IMAP - отдельные сервисы, связанные с сервисом доставки через БД пользователей
Соединяются в единую систему
Если в настройках почтового агента указан POP3, то если пользователь нажимает проверить почту
MUA связывается с POP3 с сервером входящей почты
По БД проверяется аутентификация, проверяется почтовый ящик и показывает какие письма есть и как с ними можно взаимодействовать
# Вторая функция прокси
## Виды кэширования

### Прямое кэширование

Есть прокси, у него есть кэш
Если в организации много клиентов

Клиент обратился к серверу (прокси), все что получил от хоста сохранил в кэше
Страница получает статическией контент, который уже присутствует на странице, именно это и кэшируется

Второй клиент посылает запрос на адрес ресурса, прокси идет к кэшу и возвращает контент

### Упреждающее кэширование

### Обрабтное кэширование

Прокси стоит на границе с внешней сетью
Внутри сети есть ресурсы веб-сервреа, на который запросы транслируются, либо берет результата из кэша (50 на 50)

Если все запросы идут на один прокси сервер, то он его выполняет и может не успевать выполнять все запросы
Можно использовать несколько прокси серверов
Сущесвтует 2 протокола формирования массива кэш серверов:

#### ICP

На каждом уровне по массиву кэш серверов отправляет запросы, а потом уже отправляет во внешнюю сеть
Точек много, нагрузка балансируется, данные хранятся в разных кэшах.
Хуже скорость, зато сервера более разргужены
Данные копируются из одного кэша в другой, из-за чего данные в кэше становятся одинаковыми


#### CARP (Cache array routing protocol)

Также возможны цепочки серверов, но для определения местоположения ресурса в кэше сервера
1 уровень - 1 группа, для всех есть функция кэширования. По URL указывается на каком сервере хранится
Клиент 3 делает запрос URL1 Кэш-сервер 3 отвечает за URL1. Он там сохранится, только если кэш функция
указывает что он там должен хранится
По кэш функции обратится сразу к ответсвенному по этой информации серверу
Таким образом не происходит overlaping данных на серверах
Есть четкое определение есть ли на сервере дата.

Если сервер вышел из строя, то сложно предсказать куда должны передаться адреса сервера-ownera
Если какой-то сервер выпадает из массива, то возникает необходимость перестроения, что приводит к инвалидности всех кэшей


# Брандмауэр (Firewall)

Задача устройства (или программы) - фильтрация траффика. Стоят на границе сетей траффик которых должны филтровать
Есть 2 вровня - защита хоста и защита сетей
Для хоста ставятся на компьюетры (вместе с ОС), его задача на запросы к ПК не отвечать.

Существуют Firewall как отдельные устрйоства, а есть программные.
Аппаратные могут работать быстрее (из-за аппаратного ускорения обработки траффика)


## Как работает?

Firewall идентифицирует трафик, который проходит через него

Правила (если if):
1
2
3
...
N
default

## Что может входить в правила?

1. Источник [откуда]
2. Назначение (IP или DNS) [куда]
3. Порт (определяет протокол) [как]
4. Контент [что]
5. Время [когда]
6. Пользователь [кто]

Не во всех брандмауэрах могут использоваться эти характеристики.
