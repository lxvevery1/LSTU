// Метод обратных итераций (под БОЛЬШИМ вопросом(ошибка в алгоритме))
#include<iostream>
#include<iomanip>
#include<stdio.h>
using namespace std;

#define SIZE 5

int main()
{
	float a[SIZE][SIZE] = { {0.369080808,	1.436031013, -0.728668525,	0.990262713, -1.066533038},
							{9.321890071, -1.513583362, -3.530025844, -5.518609715,	1.735434769,},
							{0.53279339, -2.264422783, -4.01783643, -5.59560245, -3.516869824, },
							{1.624855009,	1.624346269, -2.438991881,	2.43852384,	2.741387029,},
							{-7.857573106, -1.199934881, -0.823975906,	0.389003073, -6.276184856} }, x[SIZE], x_new[SIZE];
	float temp, lambda_new, lambda_old, error;
	int i, j, n, step = 1;

	cout << setprecision(4) << fixed;

	n = SIZE;
	float inverse[SIZE][SIZE] = {   {0.047,	0.43, -0.45, -0.016,	0.35,},				// inversed by hand matrix a 
									{0.72, -0.95,	1.04, -0.21, -1.06,},
									{0.073, -0.065 - 0.026 - 0.26 - 0.13},
									{-0.22,	0.73, -0.9,	0.22,	0.83},
									{-0.19, -0.4,	0.42,	0.079, -0.44} };

	error = 0.0001;

	for (i = 0; i < n; i++)
	{
		x[i] = 1;
	}

	lambda_old = 1;

up:
	for (i = 0; i < n; i++) // verno
	{
		temp = 0.0;
		for (j = 0; j < n; j++)
		{
			temp += inverse[i][j] * x[j];
		}
		x_new[i] = temp;
	}

	for (i = 0; i < n; i++) // verno
	{
		x[i] = x_new[i];
	}

	// Finding max value from x
	lambda_new = abs(x[0]);
	for (i = 0; i < n; i++)
	{
		if (abs(x[i]) > lambda_new)
		{
			lambda_new = abs(x[i]);
		}
	}

	// Normalization
	for (i = 0; i < n; i++)
	{
		x[i] /= lambda_new;
	}

	// Display
	cout << "\nEigen MinValue = " << lambda_new;
	cout << "\tEigen Vector: [";
	for (i = 0; i < n; i++)
	{
		cout << x[i] << "\t";
	}
	cout << "]";

	if (abs(lambda_new - lambda_old) >= error && step < 999)
	{
		lambda_old = lambda_new;
		step++;
		goto up;
	}

	return 0;
}